---
alwaysApply: false
description: Guia Completo de Services - L√≥gica de Neg√≥cio
---

# üíº Guia Completo de Services - L√≥gica de Neg√≥cio

## üìã Resumo Executivo

Este documento descreve o padr√£o arquitetural para Services no projeto Pare Azul API Intelligence. Os Services s√£o respons√°veis por encapsular a l√≥gica de neg√≥cio, orquestrar chamadas para APIs e repositories, e fornecer uma interface limpa para os controllers.

## üéØ Prop√≥sito dos Services

### **1. L√≥gica de Neg√≥cio**

- **Encapsulamento** de regras de neg√≥cio
- **Orquestra√ß√£o** de APIs e repositories
- **Transforma√ß√£o** de dados
- **Valida√ß√£o** de regras espec√≠ficas

### **2. Camada de Abstra√ß√£o**

- **Interface limpa** para controllers
- **Abstra√ß√£o** de complexidade
- **Reutiliza√ß√£o** de l√≥gica
- **Testabilidade** facilitada

### **3. Integra√ß√£o de Dados**

- **Agrega√ß√£o** de m√∫ltiplas fontes
- **Cache** e otimiza√ß√£o
- **Tratamento de erros** espec√≠ficos
- **Logging** de opera√ß√µes

## üèóÔ∏è Estrutura Padr√£o

### **1. Template Base**

```typescript
// src/services/[domain].service.ts
import { [DomainApi] } from '../api/[domain].api';
import { [DomainRepository] } from '../repositories/[domain].repository';
import { logger } from '../utils/logger.util';
import { [DomainType] } from '../types/[domain].types';

export class [Domain]Service {
    private readonly logger = logger.child({ service: '[Domain]Service' });

    /**
     * [Descri√ß√£o da funcionalidade]
     */
    async [methodName](params: [ParamsType]): Promise<[ReturnType]> {
        return new Promise((resolve, reject) => {
            // 1. Valida√ß√£o de par√¢metros
            if (!params.requiredField) {
                this.logger.error(`Missing required field: requiredField`);
                return reject({ text: "Missing required field." });
            }

            // 2. Busca de dados relacionados
            return this.getRelatedData(params)
                .then(async (relatedData) => {
                    // 3. Processamento da l√≥gica de neg√≥cio
                    const result = await this.processBusinessLogic(params, relatedData);

                    // 4. Retorno do resultado
                    return resolve(result);
                })
                .catch(error => {
                    // 5. Error handling espec√≠fico
                    this.logger.error('[methodName] Error:', error);
                    reject({ text: "Error processing request." });
                });
        });
    }

    /**
     * M√©todo auxiliar para buscar dados relacionados
     */
    private async getRelatedData(params: [ParamsType]): Promise<[DataType]> {
        // Implementa√ß√£o espec√≠fica
    }

    /**
     * M√©todo auxiliar para processar l√≥gica de neg√≥cio
     */
    private async processBusinessLogic(params: [ParamsType], data: [DataType]): Promise<[ReturnType]> {
        // Implementa√ß√£o espec√≠fica
    }
}

export const [domain]Service = new [Domain]Service();
```

### **2. Padr√µes Obrigat√≥rios**

```typescript
// ‚úÖ SEMPRE usar Promise pattern em services
async methodName(params: ParamsType): Promise<ReturnType> {
    return new Promise((resolve, reject) => {
        // L√≥gica do service
        return this.getData(params)
            .then(result => resolve(result))
            .catch(error => {
                this.logger.error('[methodName] Error:', error);
                reject({ text: "Error message." });
            });
    });
}

// ‚ùå NUNCA usar try/catch em services
async methodNameWrong(params: ParamsType): Promise<ReturnType> {
    try {
        const result = await this.getData(params);
        return result;
    } catch (error) {
        this.logger.error('[methodNameWrong] Error:', error);
        throw error;
    }
}
```

## üîß Componentes Obrigat√≥rios

### **1. Imports Padr√£o**

```typescript
// Imports obrigat√≥rios para todos os services
import { [DomainApi] } from '../api/[domain].api';
import { [DomainRepository] } from '../repositories/[domain].repository';
import { logger } from '../utils/logger.util';
import { [DomainType] } from '../types/[domain].types';
```

### **2. Logger Espec√≠fico**

```typescript
// Logger espec√≠fico do service
export class [Domain]Service {
    private readonly logger = logger.child({ service: '[Domain]Service' });
}
```

### **3. Estrutura de M√©todo**

```typescript
async methodName(params: ParamsType): Promise<ReturnType> {
    return new Promise((resolve, reject) => {
        // 1. Valida√ß√£o de par√¢metros
        if (!params.requiredField) {
            this.logger.error(`Missing required field: requiredField`);
            return reject({ text: "Missing required field." });
        }

        // 2. Busca de dados relacionados
        return this.getRelatedData(params)
            .then(async (relatedData) => {
                // 3. Processamento da l√≥gica de neg√≥cio
                const result = await this.processBusinessLogic(params, relatedData);

                // 4. Retorno do resultado
                return resolve(result);
            })
            .catch(error => {
                // 5. Error handling espec√≠fico
                this.logger.error('[methodName] Error:', error);
                reject({ text: "Error processing request." });
            });
    });
}
```

### **4. Error Handling Padr√£o**

```typescript
// Error handling obrigat√≥rio em todos os m√©todos
.catch(error => {
    if (error && typeof error === 'object' && 'response' in error) {
        const axiosError = error as { response?: { data?: { code?: number; message?: string } } };

        // Tratamento de erros espec√≠ficos da API
        if (axiosError.response?.data?.code === 606) {
            return {
                text: `‚ùå BLOCKED: Maximum number of active plates reached.`
            };
        }

        if (axiosError.response?.data?.code === 400 &&
            axiosError.response?.data?.message?.toLowerCase().includes('saldo')) {
            return {
                text: `‚ùå BLOCKED: Insufficient balance.`
            };
        }

        // Outros c√≥digos de erro espec√≠ficos
        if (axiosError.response?.data?.code) {
            const errorMessage = axiosError.response.data.message || 'Unknown error';
            return {
                text: `‚ùå FAILED: ${errorMessage}`
            };
        }
    }

    this.logger.error('[methodName] Error:', error);
    return {
        text: `‚ùå FAILED: An error occurred while processing the request.`
    };
});
```

## üìä Exemplos Implementados

### **1. Session Service**

```typescript
// src/services/session.service.ts
import { chatRepository } from '../repositories/chat.repository';
import { logger } from '../utils/logger.util';
import { v4 as uuidv4 } from 'uuid';

export class SessionService {
  /**
   * Cria ou recupera uma sess√£o seguindo a l√≥gica do n8n
   */
  async createSession(input: {
    payload: any;
    assistant_id?: string;
  }): Promise<SessionResult | null> {
    try {
      const { payload, assistant_id } = input;
      const userId = payload.usuario_id;

      // 1. Se tem assistant_id, tenta recuperar sess√£o existente
      if (assistant_id) {
        const existingSession = await this.findActiveSession(userId, assistant_id);
        if (existingSession) {
          logger.info(`[SessionService] Using existing session: ${existingSession.id}`);
          return {
            session: existingSession,
            assistantId: assistant_id,
            isNewSession: false,
          };
        }
      }

      // 2. Se n√£o tem assistant_id, verifica se existe alguma sess√£o ativa do usu√°rio
      if (!assistant_id) {
        const existingUserSession = await chatRepository.findActiveByUserId(userId);
        if (existingUserSession) {
          logger.info(`[SessionService] Using existing user session: ${existingUserSession.id}`);
          return {
            session: existingUserSession,
            assistantId: existingUserSession.assistant_id,
            isNewSession: false,
          };
        }
      }

      // 3. Se n√£o encontrou nenhuma sess√£o, cria nova
      logger.info(`[SessionService] Creating new session for user: ${userId}`);

      // 4. Inativa sess√µes antigas do usu√°rio (como no n8n)
      await this.inactivateOldSessions(userId);

      // 5. Cria nova sess√£o
      const newAssistantId = assistant_id || uuidv4();
      const newSession = await chatRepository.createChat({
        user_id: userId,
        prefecture_id: payload.prefeitura_id,
        assistant_id: newAssistantId,
      });

      if (!newSession) {
        logger.error('[SessionService] Failed to create new session');
        return null;
      }

      logger.info(`[SessionService] New session created: ${newSession.id}`);

      return {
        session: newSession,
        assistantId: newAssistantId,
        isNewSession: true,
      };
    } catch (error) {
      logger.error('[SessionService] Error creating session:', error);
      return null;
    }
  }
}

export const sessionService = new SessionService();
```

**Caracter√≠sticas:**

- **L√≥gica complexa** de gerenciamento de sess√µes
- **M√∫ltiplas valida√ß√µes** e condi√ß√µes
- **Integra√ß√£o** com repository
- **Logging detalhado** de cada etapa

### **2. Activation Service**

```typescript
// src/services/activation.service.ts
export class ActivationService {
  private readonly logger = logger.child({ service: 'ActivationService' });

  checkCurrentVehicleActivation(params: CheckVehicleActivationParams): Promise<{ text: string }> {
    return new Promise((resolve, reject) => {
      const { userId, vehiclePlate } = params;

      return memoryService
        .getSessionCache(userId)
        .then(async userPayload => {
          if (!userPayload) {
            this.logger.error(`User session not found for userId: ${userId}`);
            return {
              text: 'User session not found. Wrong userId provided or user session expired.',
            };
          }

          const {
            payload: { prefeitura_id: prefectureId, prefeitura_timezone: prefectureTimezone },
            prefecture_user_token: prefectureUserToken,
          } = userPayload;

          const clearPlateValue = StringUtil.clearPlate(vehiclePlate);

          const activations = await fetchVehicleCurrentActivations(
            clearPlateValue,
            prefectureId,
            prefectureTimezone,
            prefectureUserToken
          );

          if (!activations || activations.length === 0) {
            return resolve({ text: `No activation found for vehicle plate ${vehiclePlate}.` });
          }

          const latestActivation = activations[0];

          const responseText =
            `Vehicle plate ${vehiclePlate} is currently activated.` +
            `\n The current activation will expire on ${latestActivation.remaining_time} minutes.` +
            `\n Precisely, it will expire on ${latestActivation.end_date} (prefecture local time).` +
            `${latestActivation.is_extended ? '\n This activation is an extension of a previous one.' : ''}` +
            `\n More details: ${JSON.stringify(activations, null)}`;

          return resolve({ text: responseText });
        })
        .catch(error => {
          this.logger.error('Error getting user payload:', error);
          reject({ text: 'Error getting user payload.' });
        });
    });
  }
}

export const activationService = new ActivationService();
```

**Caracter√≠sticas:**

- **Promise pattern** obrigat√≥rio
- **Error handling** espec√≠fico por tipo
- **Integra√ß√£o** com m√∫ltiplas APIs
- **Transforma√ß√£o** de dados complexa

### **3. Memory Service**

```typescript
// src/services/memory.service.ts
export class MemoryService {
  private readonly SESSION_CACHE_PREFIX = 'chat_assistente_';
  private readonly MEMORY_BUFFER_PREFIX = 'memory_buffer_';
  private readonly SESSION_TTL = env.SESSION_TTL;
  private readonly BUFFER_SIZE = env.MEMORY_BUFFER_SIZE;

  /**
   * Armazena metadados da sess√£o no Redis
   */
  async setSessionCache(userId: string, sessionData: SessionCache): Promise<boolean> {
    try {
      const key = `${this.SESSION_CACHE_PREFIX}${userId}`;
      const value = JSON.stringify(sessionData);

      await redis.setEx(key, this.SESSION_TTL, value);
      logger.debug(`Session cache stored for user ${userId}`);
      return true;
    } catch (error) {
      logger.warn('Redis unavailable for session cache, using memory fallback:', error);
      // Fallback: armazenar em mem√≥ria local (n√£o persistente)
      return true;
    }
  }

  /**
   * Recupera metadados da sess√£o do Redis
   */
  async getSessionCache(userId: string): Promise<SessionCache | null> {
    try {
      const key = `${this.SESSION_CACHE_PREFIX}${userId}`;
      const value = await redis.get(key);

      if (!value) {
        return null;
      }

      return JSON.parse(value) as SessionCache;
    } catch (error) {
      logger.error('Error retrieving session cache:', error);
      return null;
    }
  }
}

export const memoryService = new MemoryService();
```

**Caracter√≠sticas:**

- **Singleton pattern** para inst√¢ncia √∫nica
- **Cache management** com Redis
- **Fallback** para mem√≥ria local
- **Configura√ß√£o** centralizada

## üéØ Melhores Pr√°ticas

### **1. Nomenclatura**

```typescript
// ‚úÖ BOM: Nomes descritivos e consistentes
export class ActivationService {}
export class SessionService {}
export class MemoryService {}

// ‚ùå RUIM: Nomes gen√©ricos ou inconsistentes
export class Service {}
export class MainService {}
export class HelperService {}
```

### **2. M√©todos**

```typescript
// ‚úÖ BOM: M√©todos espec√≠ficos e descritivos
async checkCurrentVehicleActivation(params: CheckVehicleActivationParams): Promise<{ text: string }> { }
async handleRegisterVehicleActivation(input: HandleRegisterVehicleActivationParams): Promise<{ text: string }> { }
async createSession(input: { payload: any; assistant_id?: string }): Promise<SessionResult | null> { }

// ‚ùå RUIM: M√©todos gen√©ricos ou confusos
async process(params: any): Promise<any> { }
async handle(input: any): Promise<any> { }
async doSomething(data: any): Promise<any> { }
```

### **3. Error Handling**

```typescript
// ‚úÖ BOM: Error handling espec√≠fico e informativo
.catch(error => {
    if (error && typeof error === 'object' && 'response' in error) {
        const axiosError = error as { response?: { data?: { code?: number; message?: string } } };

        if (axiosError.response?.data?.code === 606) {
            return {
                text: `‚ùå BLOCKED: Maximum number of active plates reached.`
            };
        }
    }

    this.logger.error('[methodName] Error:', error);
    return {
        text: `‚ùå FAILED: An error occurred while processing the request.`
    };
});

// ‚ùå RUIM: Error handling gen√©rico ou inadequado
.catch(error => {
    console.log('Error:', error);
    return { text: 'Error' };
});
```

### **4. Logging**

```typescript
// ‚úÖ BOM: Log espec√≠fico e informativo
this.logger.error(`User session not found for userId: ${userId}`);
logger.info(`[SessionService] Using existing session: ${existingSession.id}`);

// ‚ùå RUIM: Log gen√©rico ou desnecess√°rio
console.log('Error');
logger.info('Processing');
```

### **5. Valida√ß√£o**

```typescript
// ‚úÖ BOM: Valida√ß√£o espec√≠fica e clara
if (!userPayload) {
  this.logger.error(`User session not found for userId: ${userId}`);
  return { text: 'User session not found. Wrong userId provided or user session expired.' };
}

// ‚ùå RUIM: Valida√ß√£o gen√©rica ou inadequada
if (!params) {
  return { text: 'Invalid params' };
}
```

## üîÑ Fluxo de Execu√ß√£o

### **1. Chamada do Controller**

```
Controller ‚Üí Service Method ‚Üí Validation ‚Üí Business Logic
```

### **2. Processamento**

```
Service ‚Üí API Calls ‚Üí Data Transformation ‚Üí Response
```

### **3. Error Flow**

```
Error ‚Üí Log ‚Üí Specific Handling ‚Üí Error Response
```

## üöÄ Vantagens da Arquitetura

### **1. Encapsulamento**

- **L√≥gica de neg√≥cio** isolada
- **Interface limpa** para controllers
- **Reutiliza√ß√£o** de c√≥digo

### **2. Testabilidade**

- **M√©todos isolados** e test√°veis
- **Dependency injection** clara
- **Mocking** facilitado

### **3. Manutenibilidade**

- **Separa√ß√£o clara** de responsabilidades
- **C√≥digo organizado** e leg√≠vel
- **Logging estruturado** por dom√≠nio

### **4. Robustez**

- **Error handling** espec√≠fico
- **Valida√ß√£o robusta** de dados
- **Fallback** para falhas

## üìà Recomenda√ß√µes de Melhoria

### **1. Base Service**

```typescript
// Criar service base com funcionalidades comuns
abstract class BaseService {
  protected readonly logger = logger.child({ service: this.constructor.name });

  protected handleApiError(error: any, context: string): { text: string } {
    if (error && typeof error === 'object' && 'response' in error) {
      const axiosError = error as { response?: { data?: { code?: number; message?: string } } };

      if (axiosError.response?.data?.code === 606) {
        return { text: `‚ùå BLOCKED: Maximum number of active plates reached.` };
      }

      if (
        axiosError.response?.data?.code === 400 &&
        axiosError.response?.data?.message?.toLowerCase().includes('saldo')
      ) {
        return { text: `‚ùå BLOCKED: Insufficient balance.` };
      }

      if (axiosError.response?.data?.code) {
        const errorMessage = axiosError.response.data.message || 'Unknown error';
        return { text: `‚ùå FAILED: ${errorMessage}` };
      }
    }

    this.logger.error(`[${context}] Error:`, error);
    return { text: `‚ùå FAILED: An error occurred while processing the request.` };
  }
}
```

### **2. Service Registry**

```typescript
// Registry para gerenciar inst√¢ncias de services
class ServiceRegistry {
  private services = new Map<string, any>();

  register<T>(name: string, service: T): void {
    this.services.set(name, service);
  }

  get<T>(name: string): T {
    return this.services.get(name);
  }
}

export const serviceRegistry = new ServiceRegistry();
```

### **3. Service Metrics**

```typescript
// M√©tricas de performance para services
interface ServiceMetrics {
  name: string;
  methodName: string;
  executionTime: number;
  success: boolean;
  errorType?: string;
}

class MetricsCollector {
  static collect(
    serviceName: string,
    methodName: string,
    executionTime: number,
    success: boolean,
    errorType?: string
  ): void {
    const metrics: ServiceMetrics = {
      name: serviceName,
      methodName,
      executionTime,
      success,
      errorType,
    };

    // Enviar m√©tricas para sistema de monitoramento
    logger.info('Service metrics:', metrics);
  }
}
```

## üéØ Conclus√£o

A arquitetura de Services no projeto est√° bem estruturada e segue padr√µes consistentes. O uso de **Promise pattern** para error handling, **logging estruturado**, **valida√ß√£o robusta** e **encapsulamento** de l√≥gica de neg√≥cio garante c√≥digo limpo e maint√≠vel.

As principais melhorias seriam implementar **Base Service**, **Service Registry** e **Service Metrics** para tornar o sistema ainda mais robusto e observ√°vel.

---

_Este guia deve ser atualizado conforme a evolu√ß√£o do projeto e descobertas de melhores pr√°ticas._
