---
alwaysApply: false
description: Guia Completo de Controllers - Camada de Controle HTTP
---

# üéÆ Guia Completo de Controllers - Camada de Controle HTTP

## üìã Resumo Executivo

Este documento descreve o padr√£o arquitetural para Controllers no projeto Pare Azul API Intelligence. Os Controllers s√£o respons√°veis por receber requisi√ß√µes HTTP, validar dados de entrada, orquestrar chamadas para services e retornar respostas padronizadas.

## üéØ Prop√≥sito dos Controllers

### **1. Camada de Controle HTTP**

- **Recebimento de requisi√ß√µes** HTTP
- **Valida√ß√£o de entrada** de dados
- **Orquestra√ß√£o** de services
- **Retorno de respostas** padronizadas

### **2. Interface da API**

- **Endpoints REST** bem definidos
- **Status codes** apropriados
- **Error handling** consistente
- **Logging** de requisi√ß√µes

### **3. Separa√ß√£o de Responsabilidades**

- **N√£o cont√©m l√≥gica de neg√≥cio**
- **Delega processamento** para services
- **Foca em HTTP** e valida√ß√£o
- **Mant√©m c√≥digo limpo**

## üèóÔ∏è Estrutura Padr√£o

### **1. Template Base**

```typescript
// src/controllers/[domain].controller.ts
import { Request, Response } from 'express';
import { [DomainService] } from '../services/[domain].service';
import { logger } from '../utils/logger.util';

export class [Domain]Controller {
    /**
     * Endpoint para [funcionalidade]
     */
    async [methodName](req: Request, res: Response): Promise<void> {
        try {
            // 1. Extra√ß√£o de dados da requisi√ß√£o
            const { param1, param2 } = req.body;

            // 2. Valida√ß√£o b√°sica
            if (!param1 || !param2) {
                res.status(400).json({
                    error: 'Missing required fields: param1 and param2 are required'
                });
                return;
            }

            // 3. Log da requisi√ß√£o
            logger.info(`[[Domain]Controller] Processing [action] from user ${userId}`);

            // 4. Chamada para service
            const result = await [domainService].[methodName](param1, param2);

            // 5. Resposta de sucesso
            res.json(result);
        } catch (error) {
            // 6. Error handling
            logger.error('[[Domain]Controller] Error processing [action]:', error);

            const message = error instanceof Error ? error.message : 'An internal server error occurred.';

            if (message.includes('validation')) {
                res.status(400).json({ error: 'Invalid request data' });
            } else {
                res.status(500).json({ error: 'An internal server error occurred.' });
            }
        }
    }
}

export const [domain]Controller = new [Domain]Controller();
```

### **2. Padr√µes Obrigat√≥rios**

```typescript
// ‚úÖ SEMPRE usar Promise pattern em controllers
async methodName(req: Request, res: Response): Promise<void> {
    // Valida√ß√£o de entrada
    const { param1, param2 } = req.body;

    if (!param1 || !param2) {
        res.status(400).json({
            error: 'Missing required fields: param1 and param2 are required'
        });
        return;
    }

    logger.info(`[Controller] Processing action from user ${userId}`);

    return service.method(param1, param2)
        .then(result => {
            res.json(result);
        })
        .catch(error => {
            logger.error('[Controller] Error:', error);

            const message = error instanceof Error ? error.message : 'An internal server error occurred.';

            if (message.includes('validation')) {
                res.status(400).json({ error: 'Invalid request data' });
            } else {
                res.status(500).json({ error: 'An internal server error occurred.' });
            }
        });
}

// ‚ùå NUNCA usar try/catch em controllers
async methodNameWrong(req: Request, res: Response): Promise<void> {
    try {
        const result = await service.method();
        res.json(result);
    } catch (error) {
        logger.error('[Controller] Error:', error);
        res.status(500).json({ error: 'Internal server error' });
    }
}
```

## üîß Componentes Obrigat√≥rios

### **1. Imports Padr√£o**

```typescript
// Imports obrigat√≥rios para todos os controllers
import { Request, Response } from 'express';
import { [DomainService] } from '../services/[domain].service';
import { logger } from '../utils/logger.util';
```

### **2. Estrutura de M√©todo**

```typescript
async methodName(req: Request, res: Response): Promise<void> {
    // 1. Extra√ß√£o de dados
    const { param1, param2 } = req.body;

    // 2. Valida√ß√£o b√°sica
    if (!param1 || !param2) {
        res.status(400).json({
            error: 'Missing required fields: param1 and param2 are required'
        });
        return;
    }

    // 3. Log da requisi√ß√£o
    logger.info(`[Controller] Processing action from user ${userId}`);

    // 4. Chamada para service com Promise pattern
    return service.method(param1, param2)
        .then(result => {
            // 5. Resposta de sucesso
            res.json(result);
        })
        .catch(error => {
            // 6. Error handling
            logger.error('[Controller] Error:', error);

            const message = error instanceof Error ? error.message : 'An internal server error occurred.';

            if (message.includes('validation')) {
                res.status(400).json({ error: 'Invalid request data' });
            } else {
                res.status(500).json({ error: 'An internal server error occurred.' });
            }
        });
}
```

### **3. Error Handling Padr√£o**

```typescript
// Error handling obrigat√≥rio em todos os m√©todos usando Promise pattern
.catch(error => {
    logger.error('[Controller] Error:', error);

    const message = error instanceof Error ? error.message : 'An internal server error occurred.';

    // Diferentes tipos de erro
    if (message.includes('validation')) {
        res.status(400).json({ error: 'Invalid request data' });
    } else if (message.includes('not found')) {
        res.status(404).json({ error: 'Resource not found' });
    } else if (message.includes('unauthorized')) {
        res.status(401).json({ error: 'Unauthorized' });
    } else {
        res.status(500).json({ error: 'An internal server error occurred.' });
    }
});
```

## üìä Exemplo Implementado

### **Assistant Controller**

```typescript
// src/controllers/assistant.controller.ts
import { Request, Response } from 'express';
import { processAssistantMessage, processWebhookRequest } from '../agents/assistant';
import { logger } from '../utils/logger.util';

export class AssistantController {
  /**
   * Endpoint para processar mensagem de chat
   */
  async processMessage(req: Request, res: Response): Promise<void> {
    const { message, payload, assistant_id } = req.body;

    if (!message || !payload) {
      res.status(400).json({
        error: 'Missing required fields: message and payload are required',
      });
      return;
    }

    logger.info(`[AssistantController] Processing message from user ${payload.usuario_id}`);

    return processAssistantMessage(message, payload, assistant_id)
      .then(result => {
        res.json(result);
      })
      .catch(error => {
        logger.error('[AssistantController] Error processing message:', error);

        const errorMessage =
          error instanceof Error ? error.message : 'An internal server error occurred.';

        if (errorMessage.includes('validation')) {
          res.status(400).json({ error: 'Invalid request data' });
        } else {
          res.status(500).json({ error: 'An internal server error occurred.' });
        }
      });
  }

  /**
   * Endpoint para webhook
   */
  async webhook(req: Request, res: Response): Promise<void> {
    logger.info(`[AssistantController] Processing webhook request`);

    return processWebhookRequest(req.body)
      .then(result => {
        res.json(result);
      })
      .catch(error => {
        logger.error('[AssistantController] Error processing webhook:', error);

        res.status(500).json({
          error: 'An internal server error occurred.',
          message:
            'Desculpe, houve um erro interno e n√£o consegui completar sua solicita√ß√£o. Por favor, tente novamente.',
          message_date: new Date().toISOString(),
          assistant_id: req.body.assistant_id || 'error',
        });
      });
  }

  /**
   * Endpoint para health check espec√≠fico do chat
   */
  async health(req: Request, res: Response): Promise<void> {
    res.json({
      status: 'ok',
      service: 'assistant-agent',
      timestamp: new Date().toISOString(),
    });
  }
}

export const assistantController = new AssistantController();
```

**Caracter√≠sticas:**

- **Promise pattern** obrigat√≥rio (nunca try/catch)
- **Valida√ß√£o de entrada** obrigat√≥ria
- **Logging estruturado** por a√ß√£o
- **Error handling** espec√≠fico por endpoint
- **Respostas padronizadas** com status codes

## üéØ Melhores Pr√°ticas

### **1. Nomenclatura**

```typescript
// ‚úÖ BOM: Nomes descritivos e consistentes
export class AssistantController {}
export class UserController {}
export class VehicleController {}

// ‚ùå RUIM: Nomes gen√©ricos ou inconsistentes
export class Controller {}
export class MainController {}
export class ApiController {}
```

### **2. M√©todos**

```typescript
// ‚úÖ BOM: M√©todos espec√≠ficos e descritivos
async processMessage(req: Request, res: Response): Promise<void> { }
async webhook(req: Request, res: Response): Promise<void> { }
async health(req: Request, res: Response): Promise<void> { }

// ‚ùå RUIM: M√©todos gen√©ricos ou confusos
async handle(req: Request, res: Response): Promise<void> { }
async process(req: Request, res: Response): Promise<void> { }
async doSomething(req: Request, res: Response): Promise<void> { }
```

### **3. Valida√ß√£o**

```typescript
// ‚úÖ BOM: Valida√ß√£o espec√≠fica e clara
if (!message || !payload) {
  res.status(400).json({
    error: 'Missing required fields: message and payload are required',
  });
  return;
}

// ‚ùå RUIM: Valida√ß√£o gen√©rica ou inadequada
if (!req.body) {
  res.status(400).json({ error: 'Bad request' });
  return;
}
```

### **4. Logging**

```typescript
// ‚úÖ BOM: Log espec√≠fico e informativo
logger.info(`[AssistantController] Processing message from user ${payload.usuario_id}`);

// ‚ùå RUIM: Log gen√©rico ou desnecess√°rio
logger.info('Processing request');
console.log('User request');
```

### **5. Error Handling**

```typescript
// ‚úÖ BOM: Error handling espec√≠fico e informativo com Promise pattern
.catch(error => {
    logger.error('[AssistantController] Error processing message:', error);

    const message = error instanceof Error ? error.message : 'An internal server error occurred.';

    if (message.includes('validation')) {
        res.status(400).json({ error: 'Invalid request data' });
    } else {
        res.status(500).json({ error: 'An internal server error occurred.' });
    }
});

// ‚ùå RUIM: Error handling gen√©rico ou inadequado com try/catch
try {
    const result = await service.method();
    res.json(result);
} catch (error) {
    console.log('Error:', error);
    res.status(500).json({ error: 'Error' });
}
```

## üîÑ Fluxo de Execu√ß√£o

### **1. Requisi√ß√£o HTTP**

```
HTTP Request ‚Üí Express Router ‚Üí Middleware ‚Üí Controller
```

### **2. Processamento**

```
Controller ‚Üí Validation ‚Üí Service.then() ‚Üí Response
```

### **3. Error Flow**

```
Service.catch() ‚Üí Log ‚Üí Status Code ‚Üí Error Response
```

## üöÄ Vantagens da Arquitetura

### **1. Consist√™ncia**

- **Promise pattern** uniforme em todos os controllers
- **Error handling** padronizado com .catch()
- **Logging estruturado** por dom√≠nio

### **2. Manutenibilidade**

- **Separa√ß√£o clara** de responsabilidades
- **C√≥digo limpo** e leg√≠vel com Promise pattern
- **F√°cil debugging** com logs espec√≠ficos

### **3. Robustez**

- **Valida√ß√£o robusta** de entrada
- **Error handling** abrangente com Promise pattern
- **Status codes** apropriados

### **4. Testabilidade**

- **M√©todos isolados** e test√°veis
- **Promise pattern** facilita mocking
- **Dependency injection** clara

## üìà Recomenda√ß√µes de Melhoria

### **1. Base Controller**

```typescript
// Criar controller base com funcionalidades comuns
abstract class BaseController {
  protected handleError(error: unknown, res: Response, context: string): void {
    logger.error(`[${this.constructor.name}] ${context}:`, error);

    const message = error instanceof Error ? error.message : 'An internal server error occurred.';

    if (message.includes('validation')) {
      res.status(400).json({ error: 'Invalid request data' });
    } else {
      res.status(500).json({ error: 'An internal server error occurred.' });
    }
  }

  protected validateRequired(body: any, fields: string[]): string | null {
    for (const field of fields) {
      if (!body[field]) {
        return `Missing required field: ${field}`;
      }
    }
    return null;
  }
}
```

### **2. Response Helpers**

```typescript
// Helpers para respostas padronizadas
class ResponseHelper {
  static success(res: Response, data: any, status = 200): void {
    res.status(status).json(data);
  }

  static error(res: Response, message: string, status = 500): void {
    res.status(status).json({ error: message });
  }

  static validationError(res: Response, message: string): void {
    res.status(400).json({ error: message });
  }
}
```

### **3. Request Validation**

```typescript
// Valida√ß√£o centralizada de requests
class RequestValidator {
  static validateBody(req: Request, res: Response, schema: any): boolean {
    try {
      const validated = schema.parse(req.body);
      req.body = validated;
      return true;
    } catch (error) {
      ResponseHelper.validationError(res, 'Invalid request data');
      return false;
    }
  }
}
```

## üéØ Conclus√£o

A arquitetura de Controllers no projeto est√° bem estruturada e segue padr√µes consistentes. O uso de **Promise pattern** para error handling, **valida√ß√£o robusta** de entrada, **logging estruturado** e **respostas padronizadas** garante c√≥digo limpo e maint√≠vel.

As principais melhorias seriam implementar **Base Controller**, **Response Helpers** e **Request Validation** centralizada para tornar o sistema ainda mais robusto e consistente.

---

_Este guia deve ser atualizado conforme a evolu√ß√£o do projeto e descobertas de melhores pr√°ticas._
