---
alwaysApply: false
description: Guia Completo de Security & Auth - Seguran√ßa e Autentica√ß√£o
---

# üîê Guia Completo de Security & Auth - Seguran√ßa e Autentica√ß√£o

## üìã Resumo Executivo

Este documento descreve o padr√£o arquitetural para Security & Auth no projeto Pare Azul API Intelligence. O sistema implementa **m√∫ltiplas camadas de seguran√ßa** incluindo autentica√ß√£o baseada em headers, rate limiting, CORS, sanitiza√ß√£o de dados e detec√ß√£o de ataques, garantindo robustez e prote√ß√£o contra vulnerabilidades comuns.

## üéØ Prop√≥sito da Security & Auth

### **1. Autentica√ß√£o e Autoriza√ß√£o**

- **Autentica√ß√£o** baseada em headers (compat√≠vel com n8n)
- **Autoriza√ß√£o** granular por endpoint
- **Valida√ß√£o de tokens** customiz√°vel
- **Extra√ß√£o de user ID** de m√∫ltiplas fontes

### **2. Prote√ß√£o de Seguran√ßa**

- **Headers de seguran√ßa** com Helmet
- **Rate limiting** com Redis
- **CORS** configur√°vel por ambiente
- **Detec√ß√£o de ataques** (SQL Injection, XSS, Path Traversal)

### **3. Monitoramento e Logging**

- **Logging estruturado** de eventos de seguran√ßa
- **Request tracking** com IDs √∫nicos
- **M√©tricas de seguran√ßa** e alertas
- **Auditoria** de a√ß√µes sens√≠veis

## üèóÔ∏è Estrutura Padr√£o

### **1. Organiza√ß√£o de Arquivos**

```
src/
‚îú‚îÄ‚îÄ üõ°Ô∏è middleware/               # Middlewares de seguran√ßa
‚îÇ   ‚îú‚îÄ‚îÄ auth.middleware.ts       # Autentica√ß√£o e autoriza√ß√£o
‚îÇ   ‚îú‚îÄ‚îÄ security.middleware.ts   # Headers de seguran√ßa
‚îÇ   ‚îú‚îÄ‚îÄ rate-limit.middleware.ts # Rate limiting
‚îÇ   ‚îú‚îÄ‚îÄ cors.middleware.ts       # CORS configuration
‚îÇ   ‚îî‚îÄ‚îÄ validation.middleware.ts # Valida√ß√£o de entrada
‚îú‚îÄ‚îÄ üîß utils/                   # Utilit√°rios de seguran√ßa
‚îÇ   ‚îú‚îÄ‚îÄ crypto.util.ts          # Criptografia e IDs
‚îÇ   ‚îî‚îÄ‚îÄ validation.util.ts      # Sanitiza√ß√£o de dados
‚îî‚îÄ‚îÄ üìù types/                   # Tipos de seguran√ßa
    ‚îî‚îÄ‚îÄ auth.types.ts           # Interfaces de autentica√ß√£o
```

### **2. Conven√ß√µes de Nomenclatura**

```typescript
// ‚úÖ MIDDLEWARE: camelCase descritivo
export const createAuthMiddleware = config => {};
export const basicSecurity = helmet({});
export const ipRateLimit = createRateLimit({});

// ‚úÖ CONFIG: PascalCase com sufixo "Config"
export interface AuthMiddlewareConfig {}
export interface RateLimitConfig {}
export interface CorsConfig {}

// ‚úÖ TYPES: PascalCase com sufixo descritivo
export interface AuthenticatedRequest extends Request {}
export interface SecurityEvent {}
```

## üîê Padr√µes de Autentica√ß√£o

### **1. Middleware de Autentica√ß√£o**

```typescript
// src/middleware/auth.middleware.ts
export interface AuthMiddlewareConfig {
  headerName?: string;
  requiredAuth?: boolean;
  validateToken?: (token: string) => Promise<any>;
}

export const createAuthMiddleware = (config: AuthMiddlewareConfig = {}) => {
  const { headerName = 'authorization', requiredAuth = true, validateToken } = config;

  return async (req: AuthenticatedRequest, res: Response, next: NextFunction) => {
    try {
      const authHeader = req.headers[headerName.toLowerCase()] as string;

      if (!authHeader) {
        if (requiredAuth) {
          logger.warn('Missing authorization header', {
            ip: req.ip,
            path: req.path,
            method: req.method,
          });

          return res.status(401).json({
            error: 'Authorization header required',
            code: 'MISSING_AUTH_HEADER',
          });
        } else {
          return next();
        }
      }

      // Extrair token (suporte a Bearer token ou token direto)
      let token = authHeader;
      if (authHeader.startsWith('Bearer ')) {
        token = authHeader.substring(7);
      }

      // Valida√ß√£o customizada do token (se fornecida)
      if (validateToken) {
        try {
          const user = await validateToken(token);
          req.user = user;

          logger.debug('User authenticated', {
            userId: user?.id,
            path: req.path,
            method: req.method,
          });
        } catch (error) {
          logger.warn('Token validation failed', {
            error: error instanceof Error ? error.message : 'Unknown error',
            ip: req.ip,
            path: req.path,
            method: req.method,
          });

          return res.status(401).json({
            error: 'Invalid authentication token',
            code: 'INVALID_TOKEN',
          });
        }
      }

      next();
    } catch (error) {
      logger.error('Auth middleware error:', error);
      return res.status(500).json({
        error: 'Authentication error',
        code: 'AUTH_ERROR',
      });
    }
  };
};
```

### **2. Middlewares Pr√©-configurados**

```typescript
// Autentica√ß√£o obrigat√≥ria
export const simpleAuth = createAuthMiddleware({
  headerName: 'authorization',
  requiredAuth: true,
});

// Autentica√ß√£o opcional
export const optionalAuth = createAuthMiddleware({
  headerName: 'authorization',
  requiredAuth: false,
});

// Verifica√ß√£o de autentica√ß√£o
export const requireAuth = (req: AuthenticatedRequest, res: Response, next: NextFunction) => {
  if (!req.user) {
    return res.status(401).json({
      error: 'Authentication required',
      code: 'AUTH_REQUIRED',
    });
  }
  next();
};

// Extra√ß√£o de user ID
export const extractUserId = (req: AuthenticatedRequest, res: Response, next: NextFunction) => {
  try {
    // Prioridade: req.user.id > authorization header > body.userId > query.userId
    let userId: string | null = null;

    if (req.user?.id) {
      userId = req.user.id;
    } else if (req.headers.authorization) {
      userId = req.headers.authorization.replace('Bearer ', '');
    } else if (req.body?.userId) {
      userId = req.body.userId;
    } else if (req.query?.userId) {
      userId = req.query.userId as string;
    }

    if (userId) {
      req.user = { ...req.user, id: userId };
    }

    next();
  } catch (error) {
    logger.error('Extract userId error:', error);
    next();
  }
};
```

## üõ°Ô∏è Padr√µes de Seguran√ßa

### **1. Headers de Seguran√ßa**

```typescript
// src/middleware/security.middleware.ts
export const basicSecurity = helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      scriptSrc: ["'self'"],
      imgSrc: ["'self'", 'data:', 'https:'],
      connectSrc: ["'self'"],
      fontSrc: ["'self'"],
      objectSrc: ["'none'"],
      mediaSrc: ["'self'"],
      frameSrc: ["'none'"],
    },
  },
  crossOriginEmbedderPolicy: false,
  hsts: {
    maxAge: 31536000, // 1 ano
    includeSubDomains: true,
    preload: true,
  },
});

export const customSecurityHeaders = (req: Request, res: Response, next: NextFunction) => {
  res.setHeader('X-Content-Type-Options', 'nosniff');
  res.setHeader('X-Frame-Options', 'DENY');
  res.setHeader('X-XSS-Protection', '1; mode=block');
  res.setHeader('Referrer-Policy', 'strict-origin-when-cross-origin');
  res.setHeader('Permissions-Policy', 'geolocation=(), microphone=(), camera=()');

  next();
};
```

### **2. Detec√ß√£o de Ataques**

```typescript
export const attackDetection = (req: Request, res: Response, next: NextFunction) => {
  const suspicious = [];

  // Detectar SQL Injection
  const sqlPatterns = /(union|select|insert|delete|update|drop|create|alter|exec|script)/i;
  if (sqlPatterns.test(req.url) || sqlPatterns.test(JSON.stringify(req.body))) {
    suspicious.push('SQL_INJECTION');
  }

  // Detectar XSS
  const xssPatterns = /(<script|javascript:|on\w+\s*=)/i;
  if (xssPatterns.test(req.url) || xssPatterns.test(JSON.stringify(req.body))) {
    suspicious.push('XSS_ATTEMPT');
  }

  // Detectar Path Traversal
  const pathTraversalPatterns = /(\.\.|\/etc\/|\/proc\/|\/var\/)/i;
  if (pathTraversalPatterns.test(req.url)) {
    suspicious.push('PATH_TRAVERSAL');
  }

  if (suspicious.length > 0) {
    logger.warn('Suspicious request detected', {
      ip: req.ip,
      method: req.method,
      url: req.url,
      userAgent: req.get('User-Agent'),
      attacks: suspicious,
      requestId: (req as any).requestId,
    });

    // Em produ√ß√£o, bloquear requests suspeitas
    if (process.env.NODE_ENV === 'production' && process.env.BLOCK_ATTACKS === 'true') {
      return res.status(403).json({
        error: 'Suspicious request blocked',
        code: 'SECURITY_VIOLATION',
      });
    }
  }

  next();
};
```

### **3. Request Tracking**

```typescript
export const requestId = (req: Request, res: Response, next: NextFunction) => {
  const requestId = (req.headers['x-request-id'] as string) || CryptoUtil.generateUUID();

  (req as any).requestId = requestId;
  res.setHeader('X-Request-ID', requestId);

  next();
};

export const requestLogger = (req: Request, res: Response, next: NextFunction) => {
  const start = Date.now();
  const requestId = (req as any).requestId;

  // Log da request
  logger.info('Request started', {
    requestId,
    method: req.method,
    url: req.url,
    path: req.path,
    ip: req.ip,
    userAgent: req.get('User-Agent'),
    contentType: req.get('Content-Type'),
    contentLength: req.get('Content-Length'),
    userId: (req as any).user?.id,
  });

  // Hook para log da response
  const originalSend = res.send;
  res.send = function (body: any) {
    const duration = Date.now() - start;

    logger.info('Request completed', {
      requestId,
      method: req.method,
      url: req.url,
      statusCode: res.statusCode,
      duration: `${duration}ms`,
      contentLength: res.get('Content-Length'),
      userId: (req as any).user?.id,
    });

    return originalSend.call(this, body);
  };

  next();
};
```

## ‚ö° Padr√µes de Rate Limiting

### **1. Rate Limiter Configur√°vel**

```typescript
// src/middleware/rate-limit.middleware.ts
export interface RateLimitConfig {
  windowMs?: number;
  max?: number;
  keyGenerator?: (req: Request) => string;
  skipFailedRequests?: boolean;
  skipSuccessfulRequests?: boolean;
  message?: string;
  headers?: boolean;
}

export const createRateLimit = (config: RateLimitConfig = {}) => {
  const {
    windowMs = 15 * 60 * 1000, // 15 minutos
    max = 100, // 100 requests por janela
    keyGenerator,
    skipFailedRequests = false,
    skipSuccessfulRequests = false,
    message = 'Too many requests, please try again later',
    headers = true,
  } = config;

  return rateLimit({
    windowMs,
    max,
    message: {
      error: message,
      code: 'RATE_LIMIT_EXCEEDED',
      retryAfter: Math.ceil(windowMs / 1000),
    },
    keyGenerator: keyGenerator || ((req: Request) => ipKeyGenerator(req.ip || '127.0.0.1')),
    skipFailedRequests,
    skipSuccessfulRequests,
    standardHeaders: headers,
    legacyHeaders: false,
    // Store usando Redis com fallback para mem√≥ria
    store: {
      incr: async (key: string) => {
        try {
          const redisKey = `rate_limit:${key}`;
          const current = await redis.incr(redisKey);

          if (current === 1) {
            await redis.expire(redisKey, Math.ceil(windowMs / 1000));
          }

          return {
            totalHits: current,
            resetTime: new Date(Date.now() + windowMs),
          };
        } catch (error) {
          logger.warn('Rate limit Redis unavailable, using memory fallback:', error);
          return {
            totalHits: 1,
            resetTime: new Date(Date.now() + windowMs),
          };
        }
      },
      // ... outros m√©todos do store
    },
    handler: (req: Request, res: Response) => {
      logger.warn('Rate limit exceeded', {
        ip: req.ip,
        path: req.path,
        method: req.method,
        userAgent: req.get('User-Agent'),
        userId: (req as any).user?.id,
      });

      res.status(429).json({
        error: message,
        code: 'RATE_LIMIT_EXCEEDED',
        retryAfter: Math.ceil(windowMs / 1000),
        timestamp: new Date().toISOString(),
      });
    },
  });
};
```

### **2. Rate Limiters Pr√©-configurados**

```typescript
// Rate limit por IP (padr√£o)
export const ipRateLimit = createRateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutos
  max: 100, // 100 requests por IP
  message: 'Too many requests from this IP',
});

// Rate limit por usu√°rio autenticado
export const userRateLimit = createRateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutos
  max: 200, // 200 requests por usu√°rio
  keyGenerator: req => (req as any).user?.id || req.ip,
  message: 'Too many requests from this user',
});

// Rate limit rigoroso para APIs sens√≠veis
export const strictRateLimit = createRateLimit({
  windowMs: 5 * 60 * 1000, // 5 minutos
  max: 10, // 10 requests por janela
  message: 'Rate limit exceeded for sensitive endpoint',
});

// Rate limit din√¢mico baseado em tipo de usu√°rio
export const dynamicRateLimit = (req: Request, res: Response, next: NextFunction) => {
  const user = (req as any).user;

  let config: RateLimitConfig = {
    windowMs: 15 * 60 * 1000,
    max: 100,
  };

  if (user?.type === 'premium') {
    config.max = 500;
  } else if (user?.type === 'api') {
    config.max = 1000;
  }

  const limitMiddleware = createRateLimit(config);
  limitMiddleware(req, res, next);
};
```

## üåê Padr√µes de CORS

### **1. CORS Configur√°vel**

```typescript
// src/middleware/cors.middleware.ts
export interface CorsConfig {
  origins?: string[] | string;
  credentials?: boolean;
  methods?: string[];
  allowedHeaders?: string[];
  exposedHeaders?: string[];
  maxAge?: number;
}

export const createCorsMiddleware = (config: CorsConfig = {}) => {
  const {
    origins = process.env.CORS_ORIGINS?.split(',') || ['http://localhost:3000'],
    credentials = true,
    methods = ['GET', 'POST', 'PUT', 'PATCH', 'DELETE', 'OPTIONS'],
    allowedHeaders = ['Content-Type', 'Authorization', 'X-Requested-With'],
    exposedHeaders = ['X-Total-Count', 'X-Page-Count'],
    maxAge = 86400, // 24 horas
  } = config;

  const corsOptions: CorsOptions = {
    origin: (origin, callback) => {
      // Permitir requests sem origin (mobile apps, Postman, etc.)
      if (!origin) {
        return callback(null, true);
      }

      // Verificar se origin est√° na lista permitida
      const allowedOrigins = Array.isArray(origins) ? origins : [origins];

      if (allowedOrigins.includes('*') || allowedOrigins.includes(origin)) {
        callback(null, true);
      } else {
        logger.warn('CORS blocked origin:', { origin, allowedOrigins });
        callback(new Error('Not allowed by CORS'));
      }
    },
    credentials,
    methods,
    allowedHeaders,
    exposedHeaders,
    maxAge,
    optionsSuccessStatus: 200,
  };

  return cors(corsOptions);
};
```

### **2. CORS Pr√©-configurados**

```typescript
// CORS permissivo para desenvolvimento
export const devCors = createCorsMiddleware({
  origins: '*',
  credentials: true,
});

// CORS restritivo para produ√ß√£o
export const prodCors = createCorsMiddleware({
  origins: process.env.CORS_ORIGINS?.split(',') || [],
  credentials: true,
});

// CORS para APIs p√∫blicas
export const publicApiCors = createCorsMiddleware({
  origins: '*',
  credentials: false,
  methods: ['GET', 'POST'],
});

// CORS padr√£o baseado no ambiente
export const defaultCors = process.env.NODE_ENV === 'production' ? prodCors : devCors;
```

## üìä Exemplos Implementados

### **1. Aplica√ß√£o de Middlewares**

```typescript
// src/routes/assistant.route.ts
import { Router } from 'express';
import { assistantController } from '../controllers/assistant.controller';
import { simpleAuth, ipRateLimit, defaultCors } from '../middleware';

const router = Router();

// Aplicar middlewares de seguran√ßa
router.use(defaultCors);
router.use(ipRateLimit);
router.use(simpleAuth);

// Rotas protegidas
router.post('/message', assistantController.processMessage);
router.post('/webhook', assistantController.webhook);
router.get('/health', assistantController.health);

export default router;
```

### **2. Valida√ß√£o de Entrada**

```typescript
// src/middleware/validation.middleware.ts
export const validateRequest = (schema: z.ZodSchema) => {
  return (req: Request, res: Response, next: NextFunction) => {
    try {
      const validated = schema.parse(req.body);
      req.body = validated;
      next();
    } catch (error) {
      if (error instanceof z.ZodError) {
        logger.warn('Validation error:', {
          errors: error.errors,
          body: req.body,
          ip: req.ip,
          userId: (req as any).user?.id,
        });

        return res.status(400).json({
          error: 'Invalid request data',
          code: 'VALIDATION_ERROR',
          details: error.errors,
        });
      }

      logger.error('Validation middleware error:', error);
      return res.status(500).json({
        error: 'Internal server error',
        code: 'VALIDATION_ERROR',
      });
    }
  };
};
```

### **3. Sanitiza√ß√£o de Dados**

```typescript
// src/utils/validation.util.ts
export class ValidationUtil {
  /**
   * Sanitizar HTML b√°sico (remove tags perigosas)
   */
  static sanitizeHtml(input: string): string {
    return input
      .replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '')
      .replace(/<iframe\b[^<]*(?:(?!<\/iframe>)<[^<]*)*<\/iframe>/gi, '')
      .replace(/javascript:/gi, '')
      .replace(/on\w+="[^"]*"/gi, '');
  }

  /**
   * Validar e sanitizar entrada de texto
   */
  static sanitizeText(input: string, maxLength: number = 1000): string {
    if (!input || typeof input !== 'string') {
      return '';
    }

    return input
      .trim()
      .substring(0, maxLength)
      .replace(/[\u0000-\u001f\u007f-\u009f]/g, '') // Remove control characters
      .replace(/\s+/g, ' '); // Normalize whitespace
  }

  /**
   * Validar email
   */
  static isValidEmail(email: string): boolean {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email);
  }
}
```

## üéØ Melhores Pr√°ticas

### **1. Configura√ß√£o de Ambiente**

```typescript
// ‚úÖ BOM: Configura√ß√£o baseada em ambiente
export const defaultCors = process.env.NODE_ENV === 'production' ? prodCors : devCors;

// ‚ùå RUIM: Configura√ß√£o hardcoded
export const cors = createCorsMiddleware({
  origins: 'https://app.example.com',
});
```

### **2. Logging de Seguran√ßa**

```typescript
// ‚úÖ BOM: Logging estruturado com contexto
logger.warn('Suspicious request detected', {
  ip: req.ip,
  method: req.method,
  url: req.url,
  userAgent: req.get('User-Agent'),
  attacks: suspicious,
  requestId: (req as any).requestId,
});

// ‚ùå RUIM: Logging gen√©rico
console.log('Suspicious request');
```

### **3. Error Handling**

```typescript
// ‚úÖ BOM: Error handling espec√≠fico com c√≥digos
return res.status(401).json({
  error: 'Authorization header required',
  code: 'MISSING_AUTH_HEADER',
});

// ‚ùå RUIM: Error handling gen√©rico
return res.status(401).json({ error: 'Unauthorized' });
```

### **4. Rate Limiting**

```typescript
// ‚úÖ BOM: Rate limiting baseado em usu√°rio
export const userRateLimit = createRateLimit({
  keyGenerator: req => (req as any).user?.id || req.ip,
  max: 200,
});

// ‚ùå RUIM: Rate limiting apenas por IP
export const rateLimit = createRateLimit({
  max: 100,
});
```

### **5. Valida√ß√£o**

```typescript
// ‚úÖ BOM: Valida√ß√£o com Zod schemas
export const validateRequest = (schema: z.ZodSchema) => {
  return (req: Request, res: Response, next: NextFunction) => {
    try {
      const validated = schema.parse(req.body);
      req.body = validated;
      next();
    } catch (error) {
      // Error handling
    }
  };
};

// ‚ùå RUIM: Valida√ß√£o manual
if (!req.body.email || !req.body.password) {
  return res.status(400).json({ error: 'Missing fields' });
}
```

## üîÑ Fluxo de Execu√ß√£o

### **1. Request Flow**

```
HTTP Request ‚Üí CORS ‚Üí Rate Limit ‚Üí Security Headers ‚Üí Auth ‚Üí Validation ‚Üí Controller
```

### **2. Security Flow**

```
Request ‚Üí Attack Detection ‚Üí Request Tracking ‚Üí Logging ‚Üí Response
```

### **3. Auth Flow**

```
Request ‚Üí Extract Token ‚Üí Validate Token ‚Üí Set User ‚Üí Next Middleware
```

## üöÄ Vantagens da Arquitetura

### **1. Seguran√ßa Robusta**

- **M√∫ltiplas camadas** de prote√ß√£o
- **Detec√ß√£o proativa** de ataques
- **Rate limiting** inteligente
- **Headers de seguran√ßa** completos

### **2. Flexibilidade**

- **Configura√ß√£o** por ambiente
- **Middlewares** reutiliz√°veis
- **Autentica√ß√£o** customiz√°vel
- **CORS** configur√°vel

### **3. Monitoramento**

- **Logging estruturado** de eventos
- **Request tracking** com IDs √∫nicos
- **M√©tricas** de seguran√ßa
- **Auditoria** completa

### **4. Manutenibilidade**

- **Separa√ß√£o clara** de responsabilidades
- **C√≥digo modular** e test√°vel
- **Configura√ß√£o** centralizada
- **Documenta√ß√£o** clara

## üìà Recomenda√ß√µes de Melhoria

### **1. JWT Authentication**

```typescript
// src/middleware/jwt.middleware.ts
export const jwtAuth = (req: Request, res: Response, next: NextFunction) => {
  try {
    const token = req.headers.authorization?.replace('Bearer ', '');

    if (!token) {
      return res.status(401).json({ error: 'Token required' });
    }

    const decoded = jwt.verify(token, process.env.JWT_SECRET!);
    req.user = decoded;
    next();
  } catch (error) {
    return res.status(401).json({ error: 'Invalid token' });
  }
};
```

### **2. Role-Based Access Control**

```typescript
// src/middleware/rbac.middleware.ts
export const requireRole = (roles: string[]) => {
  return (req: Request, res: Response, next: NextFunction) => {
    const user = (req as any).user;

    if (!user || !roles.includes(user.role)) {
      return res.status(403).json({ error: 'Insufficient permissions' });
    }

    next();
  };
};
```

### **3. Security Monitoring**

```typescript
// src/utils/security-monitor.util.ts
export class SecurityMonitor {
  static async logSecurityEvent(event: SecurityEvent): Promise<void> {
    await logger.warn('Security event', {
      type: event.type,
      severity: event.severity,
      ip: event.ip,
      userId: event.userId,
      details: event.details,
      timestamp: new Date().toISOString(),
    });
  }

  static async checkSuspiciousActivity(userId: string): Promise<boolean> {
    // Implementar l√≥gica de detec√ß√£o de atividade suspeita
    return false;
  }
}
```

### **4. Input Sanitization**

```typescript
// src/middleware/sanitization.middleware.ts
export const sanitizeInput = (req: Request, res: Response, next: NextFunction) => {
  if (req.body) {
    req.body = sanitizeObject(req.body);
  }

  if (req.query) {
    req.query = sanitizeObject(req.query);
  }

  next();
};

function sanitizeObject(obj: any): any {
  if (typeof obj === 'string') {
    return ValidationUtil.sanitizeText(obj);
  }

  if (Array.isArray(obj)) {
    return obj.map(sanitizeObject);
  }

  if (obj && typeof obj === 'object') {
    const sanitized: any = {};
    for (const [key, value] of Object.entries(obj)) {
      sanitized[key] = sanitizeObject(value);
    }
    return sanitized;
  }

  return obj;
}
```

## üéØ Conclus√£o

A arquitetura de Security & Auth no projeto est√° bem estruturada e implementa m√∫ltiplas camadas de prote√ß√£o. O uso de **middlewares modulares**, **rate limiting inteligente**, **detec√ß√£o de ataques**, **logging estruturado** e **configura√ß√£o flex√≠vel** garante seguran√ßa robusta e manutenibilidade.

As principais melhorias seriam implementar **JWT authentication**, **Role-Based Access Control**, **Security Monitoring** e **Input Sanitization** avan√ßada para tornar o sistema ainda mais seguro e robusto.

---

_Este guia deve ser atualizado conforme a evolu√ß√£o do projeto e descobertas de melhores pr√°ticas._
