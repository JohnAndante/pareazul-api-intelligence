---
alwaysApply: false
description: Guia Completo de Types & Schemas - Tipagem e Valida√ß√£o de Dados
---

# üìù Guia Completo de Types & Schemas - Tipagem e Valida√ß√£o de Dados

## üìã Resumo Executivo

Este documento descreve o padr√£o arquitetural para Types e Schemas no projeto Pare Azul API Intelligence. O sistema utiliza **TypeScript interfaces** para tipagem est√°tica e **Zod schemas** para valida√ß√£o de dados em tempo de execu√ß√£o, garantindo type safety e robustez em toda a aplica√ß√£o.

## üéØ Prop√≥sito dos Types & Schemas

### **1. Type Safety**

- **Tipagem est√°tica** em tempo de compila√ß√£o
- **IntelliSense** e autocomplete
- **Detec√ß√£o de erros** antes da execu√ß√£o
- **Refactoring** seguro

### **2. Valida√ß√£o de Dados**

- **Valida√ß√£o em runtime** com Zod
- **Schemas centralizados** e reutiliz√°veis
- **Mensagens de erro** padronizadas
- **Transforma√ß√£o** de dados

### **3. Documenta√ß√£o Viva**

- **Contratos de API** bem definidos
- **Estrutura de dados** clara
- **Exemplos** de uso
- **Manutenibilidade** alta

## üèóÔ∏è Estrutura Padr√£o

### **1. Organiza√ß√£o de Arquivos**

```
src/
‚îú‚îÄ‚îÄ üìù types/                    # TypeScript interfaces
‚îÇ   ‚îú‚îÄ‚îÄ activation.types.ts      # Tipos de ativa√ß√£o
‚îÇ   ‚îú‚îÄ‚îÄ chat.types.ts           # Tipos de chat e sess√£o
‚îÇ   ‚îú‚îÄ‚îÄ vehicle.types.ts        # Tipos de ve√≠culos
‚îÇ   ‚îú‚îÄ‚îÄ prefecture.types.ts     # Tipos de prefeitura
‚îÇ   ‚îî‚îÄ‚îÄ session.types.ts        # Tipos de sess√£o
‚îú‚îÄ‚îÄ ‚úÖ validators/               # Zod schemas
‚îÇ   ‚îú‚îÄ‚îÄ activation.validator.ts  # Valida√ß√£o de ativa√ß√£o
‚îÇ   ‚îú‚îÄ‚îÄ user.validator.ts       # Valida√ß√£o de usu√°rio
‚îÇ   ‚îú‚îÄ‚îÄ vehicle.validator.ts    # Valida√ß√£o de ve√≠culo
‚îÇ   ‚îú‚îÄ‚îÄ prefecture.validator.ts # Valida√ß√£o de prefeitura
‚îÇ   ‚îî‚îÄ‚îÄ notification.validator.ts # Valida√ß√£o de notifica√ß√£o
‚îî‚îÄ‚îÄ üìä schemas/                  # Schemas adicionais (futuro)
```

### **2. Conven√ß√µes de Nomenclatura**

```typescript
// ‚úÖ TYPES: PascalCase com sufixo descritivo
export interface VehicleActivation {}
export interface ChatPayload {}
export interface SessionCache {}

// ‚úÖ SCHEMAS: PascalCase com sufixo "Schema"
export const CheckVehicleActivationSchema = z.object({});
export const RegisterVehicleActivationSchema = z.object({});

// ‚úÖ INPUT TYPES: PascalCase com sufixo "Input"
export type CheckVehicleActivationInput = z.infer<typeof CheckVehicleActivationSchema>;
export type RegisterVehicleActivationInput = z.infer<typeof RegisterVehicleActivationSchema>;
```

## üîß Padr√µes de Types

### **1. Interface Structure**

```typescript
// src/types/[domain].types.ts
export interface [Domain]Entity {
    // Identificadores
    id: string | number;

    // Propriedades obrigat√≥rias
    name: string;
    status: 'active' | 'inactive';

    // Propriedades opcionais
    description?: string;
    metadata?: Record<string, any>;

    // Timestamps
    created_at: string;
    updated_at?: string;
}

// Service parameters
export interface Handle[Domain]Params {
    userId: string;
    [param]: [type];
}

// API response types
export interface API[Domain]Response {
    data: [Domain]Entity[];
    total: number;
    page: number;
}
```

### **2. Domain-Specific Types**

```typescript
// src/types/activation.types.ts
export interface VehicleActivation {
  currently_active: boolean;
  remaining_time: number;
  start_date: string;
  end_date: string;
  value: number;
  activation_time: number;
  is_extended: boolean;
  total_duration_minutes: number;
}

export interface HandleRegisterVehicleActivationParams {
  userId: string;
  vehiclePlate: string;
  timeValueRuleId: number;
  previousActivationId?: number;
  extend: boolean;
}

export interface RawVehicleActivation {
  id: number;
  codigo: string;
  veiculo_usuario_placa: string;
  data_criacao: string;
  // ... outros campos da API externa
}
```

### **3. Service Types (Obrigat√≥rio)**

**REGRA CR√çTICA:** Todos os services DEVEM ter tipos externos para par√¢metros e retornos.

```typescript
// src/types/[domain].types.ts

// Service parameter types
export interface GetUserVehiclesParams {
  userId: number;
  plate?: string;
  model?: string;
}

export interface RegisterUserVehicleParams {
  userId: number;
  vehicle: {
    plate: string;
    model: string;
    vehicle_type_id: number;
  };
}

// Service response types
export interface GetUserVehiclesResponse {
  text: string;
  data?: FormattedVehicle[];
}

export interface RegisterUserVehicleResponse {
  text: string;
}
```

#### **Conven√ß√µes de Nomenclatura para Services:**

```typescript
// ‚úÖ BOM: Padr√£o consistente
export interface Get[Entity]Params { }           // Par√¢metros de entrada
export interface Get[Entity]Response { }         // Resposta de sa√≠da
export interface Create[Entity]Params { }        // Par√¢metros de cria√ß√£o
export interface Create[Entity]Response { }      // Resposta de cria√ß√£o

// ‚ùå RUIM: Nomenclatura inconsistente
export interface UserVehiclesInput { }           // Deve ser GetUserVehiclesParams
export interface VehicleResult { }               // Deve ser GetUserVehiclesResponse
```

### **3. Chat & Session Types**

```typescript
// src/types/chat.types.ts
export interface ChatSession {
  id: string;
  user_id: string;
  prefecture_id: string;
  assistant_id: string;
  is_active: boolean;
  created_at: string;
  inactivated_at?: string;
}

export interface ChatPayload {
  prefeitura_id: string;
  prefeitura_sigla: string;
  prefeitura_nome: string;
  prefeitura_timezone: string;
  usuario_id: string;
  usuario_nome: string;
  usuario_email: string;
  usuario_cpf: string;
}

export interface WebhookRequest {
  session_id: string;
  payload: ChatPayload;
  prefecture_user_token: string;
  message: string;
  message_date: string;
  message_date_local: string;
  assistant_id?: string;
  new_chat?: boolean;
}
```

## ‚úÖ Padr√µes de Schemas (Zod)

### **1. Schema Structure**

```typescript
// src/validators/[domain].validator.ts
import { z } from 'zod';

export const [Domain]Schema = z.object({
    // Campos obrigat√≥rios
    id: z.string().min(1, 'ID is required'),
    name: z.string().min(1, 'Name is required'),

    // Campos com valida√ß√£o espec√≠fica
    email: z.string().email('Invalid email format'),
    phone: z.string().regex(/^\(\d{2}\)\s\d{4,5}-\d{4}$/, 'Invalid phone format'),

    // Campos opcionais
    description: z.string().optional(),

    // Campos com transforma√ß√£o
    age: z.coerce.number().int().min(0).max(120),

    // Enums
    status: z.enum(['active', 'inactive', 'pending']),

    // Arrays
    tags: z.array(z.string()).optional(),

    // Objetos aninhados
    address: z.object({
        street: z.string(),
        number: z.string(),
        city: z.string(),
        state: z.string().length(2),
        zipCode: z.string().regex(/^\d{5}-?\d{3}$/)
    }).optional()
});

export type [Domain]Input = z.infer<typeof [Domain]Schema>;
```

### **2. Validation Patterns**

```typescript
// Valida√ß√£o de placa de ve√≠culo
export const VehiclePlateSchema = z
  .string()
  .trim()
  .regex(/^[A-Z]{3}[0-9][0-9A-Z][0-9]{2}$/, 'Vehicle plate must be a valid plate number')
  .min(7, 'Vehicle plate must be at least 7 characters')
  .max(8, 'Vehicle plate must be at most 8 characters');

// Valida√ß√£o de CPF
export const CPFSchema = z
  .string()
  .regex(/^\d{3}\.\d{3}\.\d{3}-\d{2}$/, 'CPF must be in format 000.000.000-00')
  .refine(cpf => {
    // L√≥gica de valida√ß√£o de CPF
    return validateCPF(cpf);
  }, 'Invalid CPF');

// Valida√ß√£o de coordenadas
export const CoordinateSchema = z
  .number()
  .min(-90, 'Latitude must be between -90 and 90')
  .max(90, 'Latitude must be between -90 and 90');

// Valida√ß√£o de data
export const DateSchema = z
  .string()
  .datetime('Invalid date format')
  .transform(date => new Date(date));
```

### **3. Schema Composition**

```typescript
// Schemas base reutiliz√°veis
export const BaseEntitySchema = z.object({
  id: z.string().min(1),
  created_at: z.string().datetime(),
  updated_at: z.string().datetime().optional(),
});

export const UserSchema = BaseEntitySchema.extend({
  name: z.string().min(1),
  email: z.string().email(),
  cpf: CPFSchema,
});

export const VehicleSchema = BaseEntitySchema.extend({
  plate: VehiclePlateSchema,
  model: z.string().min(1),
  type_id: z.number().int().positive(),
});

// Schemas compostos
export const UserWithVehiclesSchema = UserSchema.extend({
  vehicles: z.array(VehicleSchema),
});
```

## üìä Exemplos Implementados

### **1. Activation Types**

```typescript
// src/types/activation.types.ts
export interface VehicleActivation {
  currently_active: boolean;
  remaining_time: number;
  start_date: string;
  end_date: string;
  value: number;
  activation_time: number;
  is_extended: boolean;
  total_duration_minutes: number;
}

export interface HandleRegisterVehicleActivationParams {
  userId: string;
  vehiclePlate: string;
  timeValueRuleId: number;
  previousActivationId?: number;
  extend: boolean;
}

export interface RawVehicleActivation {
  id: number;
  codigo: string;
  veiculo_usuario_placa: string;
  data_criacao: string;
  data_inicio_ativacao: string;
  data_final_ativacao: string;
  motivo_atualizacao: string;
  informacao_adicional: string;
  endereco_logradouro: string;
  endereco_numero: string;
  endereco_bairro: string;
  estado: string;
  latitude: number;
  longitude: number;
  ativacao_anterior_id: number;
  prefeitura_id: number;
  regra_valor_tempo_id: number;
  vendedor_id: number;
  conta_usuario_id: number;
  tipo_veiculo_id: number;
  uuid_ativacao: string;
  imei_dispositivo: string;
  uuid_dispositivo: string;
  numero_vaga: string;
  origem: string;
  valor: number;
  tempo: number;
}
```

### **2. Activation Validators**

```typescript
// src/validators/activation.validator.ts
import { z } from 'zod';

export const CheckVehicleActivationSchema = z.object({
  userId: z.string().min(1, 'User ID is required'),
  vehiclePlate: z
    .string()
    .trim()
    .regex(/^[A-Z]{3}[0-9][0-9A-Z][0-9]{2}$/, 'Vehicle plate must be a valid plate number')
    .min(7, 'Vehicle plate must be at least 7 characters')
    .max(8, 'Vehicle plate must be at most 8 characters'),
});

export type CheckVehicleActivationInput = z.infer<typeof CheckVehicleActivationSchema>;

export const RegisterVehicleActivationSchema = z.object({
  userId: z.string().min(1, 'User ID is required'),
  vehiclePlate: z
    .string()
    .trim()
    .regex(/^[A-Z]{3}[0-9][0-9A-Z][0-9]{2}$/, 'Vehicle plate must be a valid plate number')
    .min(7, 'Vehicle plate must be at least 7 characters')
    .max(8, 'Vehicle plate must be at most 8 characters'),
  timeValueRuleId: z
    .number()
    .int('Time value rule ID must be an integer')
    .positive('Time value rule ID must be positive'),
  previousActivationId: z
    .number()
    .int('Previous activation ID must be an integer')
    .positive('Previous activation ID must be positive')
    .optional(),
  extend: z.boolean(),
});

export type RegisterVehicleActivationInput = z.infer<typeof RegisterVehicleActivationSchema>;
```

## üéØ Melhores Pr√°ticas

### **1. Nomenclatura**

```typescript
// ‚úÖ BOM: Nomes descritivos e consistentes
export interface VehicleActivation {}
export interface ChatPayload {}
export interface SessionCache {}

// ‚ùå RUIM: Nomes gen√©ricos ou inconsistentes
export interface Data {}
export interface Item {}
export interface Info {}
```

### **2. Organiza√ß√£o**

```typescript
// ‚úÖ BOM: Agrupamento l√≥gico por dom√≠nio
export interface VehicleActivation {}
export interface HandleRegisterVehicleActivationParams {}
export interface RawVehicleActivation {}

// ‚ùå RUIM: Mistura de dom√≠nios
export interface VehicleActivation {}
export interface UserData {}
export interface ChatMessage {}
```

### **3. Tipagem**

```typescript
// ‚úÖ BOM: Tipos espec√≠ficos e descritivos
export interface VehicleActivation {
  currently_active: boolean;
  remaining_time: number;
  start_date: string;
  end_date: string;
  value: number;
  activation_time: number;
  is_extended: boolean;
  total_duration_minutes: number;
}

// ‚ùå RUIM: Tipos gen√©ricos ou any
export interface VehicleActivation {
  data: any;
  info: any;
  details: any;
}
```

### **4. Valida√ß√£o**

```typescript
// ‚úÖ BOM: Valida√ß√£o espec√≠fica e clara
export const VehiclePlateSchema = z
  .string()
  .trim()
  .regex(/^[A-Z]{3}[0-9][0-9A-Z][0-9]{2}$/, 'Vehicle plate must be a valid plate number')
  .min(7, 'Vehicle plate must be at least 7 characters')
  .max(8, 'Vehicle plate must be at most 8 characters');

// ‚ùå RUIM: Valida√ß√£o gen√©rica ou inadequada
export const VehiclePlateSchema = z.string();
```

### **5. Documenta√ß√£o**

```typescript
// ‚úÖ BOM: Coment√°rios descritivos
export interface VehicleActivation {
  /** Whether the vehicle is currently active */
  currently_active: boolean;
  /** Remaining time in minutes */
  remaining_time: number;
  /** Activation start date in ISO format */
  start_date: string;
  /** Activation end date in ISO format */
  end_date: string;
  /** Activation value in Brazilian Real */
  value: number;
  /** Activation time in minutes */
  activation_time: number;
  /** Whether this is an extension of previous activation */
  is_extended: boolean;
  /** Total duration in minutes */
  total_duration_minutes: number;
}

// ‚ùå RUIM: Sem documenta√ß√£o ou coment√°rios inadequados
export interface VehicleActivation {
  currently_active: boolean; // boolean
  remaining_time: number; // number
  start_date: string; // string
}
```

## üîÑ Fluxo de Execu√ß√£o

### **1. Defini√ß√£o de Types**

```
Domain Analysis ‚Üí Interface Definition ‚Üí Type Export ‚Üí Usage in Services
```

### **2. Cria√ß√£o de Schemas**

```
Validation Requirements ‚Üí Zod Schema ‚Üí Input Type ‚Üí Validation in Controllers
```

### **3. Valida√ß√£o de Dados**

```
HTTP Request ‚Üí Zod Schema ‚Üí Validation ‚Üí Type Safety ‚Üí Service Processing
```

## üöÄ Vantagens da Arquitetura

### **1. Type Safety**

- **Compile-time** error detection
- **IntelliSense** e autocomplete
- **Refactoring** seguro
- **Documentation** autom√°tica

### **2. Runtime Validation**

- **Data integrity** garantida
- **Error messages** claras
- **Transformation** de dados
- **Schema evolution** suportada

### **3. Manutenibilidade**

- **Centralized** type definitions
- **Reusable** schemas
- **Consistent** validation
- **Easy** to update

### **4. Developer Experience**

- **Better** IDE support
- **Faster** development
- **Fewer** runtime errors
- **Clear** contracts

## üìà Recomenda√ß√µes de Melhoria

### **1. Schema Validation Utils**

```typescript
// src/utils/schema.util.ts
export class SchemaValidator {
  static validate<T>(schema: z.ZodSchema<T>, data: unknown): T {
    try {
      return schema.parse(data);
    } catch (error) {
      if (error instanceof z.ZodError) {
        throw new ValidationError('Invalid data', error.errors);
      }
      throw error;
    }
  }

  static validateAsync<T>(schema: z.ZodSchema<T>, data: unknown): Promise<T> {
    return schema.parseAsync(data);
  }
}
```

### **2. Type Guards**

```typescript
// src/utils/type-guards.util.ts
export function isVehicleActivation(obj: any): obj is VehicleActivation {
  return (
    obj &&
    typeof obj.currently_active === 'boolean' &&
    typeof obj.remaining_time === 'number' &&
    typeof obj.start_date === 'string' &&
    typeof obj.end_date === 'string'
  );
}

export function isChatPayload(obj: any): obj is ChatPayload {
  return (
    obj &&
    typeof obj.prefeitura_id === 'string' &&
    typeof obj.usuario_id === 'string' &&
    typeof obj.usuario_nome === 'string' &&
    typeof obj.usuario_email === 'string'
  );
}
```

### **3. Schema Composition**

```typescript
// src/schemas/base.schema.ts
export const BaseEntitySchema = z.object({
  id: z.string().min(1),
  created_at: z.string().datetime(),
  updated_at: z.string().datetime().optional(),
});

export const TimestampSchema = z.object({
  created_at: z.string().datetime(),
  updated_at: z.string().datetime().optional(),
});

export const PaginationSchema = z.object({
  page: z.number().int().min(1).default(1),
  limit: z.number().int().min(1).max(100).default(20),
  total: z.number().int().min(0),
});
```

### **4. Error Handling**

```typescript
// src/types/error.types.ts
export interface ValidationError {
  field: string;
  message: string;
  code: string;
}

export interface SchemaError {
  message: string;
  errors: ValidationError[];
  statusCode: number;
}

// src/utils/error.util.ts
export class SchemaErrorHandler {
  static formatZodError(error: z.ZodError): SchemaError {
    return {
      message: 'Validation failed',
      errors: error.errors.map(err => ({
        field: err.path.join('.'),
        message: err.message,
        code: err.code,
      })),
      statusCode: 400,
    };
  }
}
```

## üéØ Conclus√£o

A arquitetura de Types & Schemas no projeto est√° bem estruturada e segue padr√µes consistentes. O uso de **TypeScript interfaces** para tipagem est√°tica e **Zod schemas** para valida√ß√£o de dados garante type safety, robustez e manutenibilidade.

As principais melhorias seriam implementar **Schema Validation Utils**, **Type Guards**, **Schema Composition** e **Error Handling** centralizado para tornar o sistema ainda mais robusto e consistente.

---

_Este guia deve ser atualizado conforme a evolu√ß√£o do projeto e descobertas de melhores pr√°ticas._
