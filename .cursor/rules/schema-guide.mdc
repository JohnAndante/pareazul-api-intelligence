---
alwaysApply: false
description: Guia de Schemas (Valida√ß√£o de entradas e sa√≠das de m√©todos e fun√ß√µes)
---

# üìã Schema Guide - Guia de Schemas

## üìã Resumo Executivo

Este guia define o padr√£o de cria√ß√£o e organiza√ß√£o de schemas de valida√ß√£o no projeto Pare Azul API Intelligence. Os schemas s√£o utilizados para valida√ß√£o de rotas HTTP e garantem type safety em toda a aplica√ß√£o.

## üéØ Estrutura de Schemas

### **Organiza√ß√£o de Arquivos**

```
src/
‚îú‚îÄ‚îÄ schemas/                    # Schemas Zod para tools/services
‚îÇ   ‚îú‚îÄ‚îÄ activation.schema.ts    # Schemas de ativa√ß√µes
‚îÇ   ‚îú‚îÄ‚îÄ database.schema.ts      # Schemas de banco de dados
‚îÇ   ‚îú‚îÄ‚îÄ faq.schema.ts           # Schemas de FAQ
‚îÇ   ‚îú‚îÄ‚îÄ notification.schema.ts  # Schemas de notifica√ß√µes
‚îÇ   ‚îú‚îÄ‚îÄ prefecture.schema.ts    # Schemas de prefeitura
‚îÇ   ‚îú‚îÄ‚îÄ shared.schema.ts        # Schemas compartilhados
‚îÇ   ‚îú‚îÄ‚îÄ user.schema.ts          # Schemas de usu√°rios
‚îÇ   ‚îî‚îÄ‚îÄ vehicle.schema.ts       # Schemas de ve√≠culos
‚îú‚îÄ‚îÄ validators/                 # Validadores de rotas HTTP
‚îÇ   ‚îú‚îÄ‚îÄ assistant.validator.ts  # Valida√ß√£o das rotas do assistant
‚îÇ   ‚îî‚îÄ‚îÄ metrics.validator.ts    # Valida√ß√£o das rotas de m√©tricas
‚îî‚îÄ‚îÄ types/                      # Defini√ß√µes de tipos TypeScript
    ‚îú‚îÄ‚îÄ chat.types.ts
    ‚îú‚îÄ‚îÄ user.types.ts
    ‚îî‚îÄ‚îÄ metrics.types.ts
```

## üèóÔ∏è Padr√£o de Cria√ß√£o de Schemas

### **Estrutura Base**

```typescript
import { z } from 'zod';

/**
 * üìã [Nome] Schemas
 *
 * Schemas Zod para [funcionalidade]
 */

export const [Nome]Schema = z.object({
    // Campos obrigat√≥rios
    campoObrigatorio: z.string().min(1, 'Campo obrigat√≥rio'),

    // Campos opcionais
    campoOpcional: z.string().optional(),

    // Valida√ß√µes customizadas
    campoCustomizado: z.string()
        .regex(/^[A-Z]{3}[0-9][0-9A-Z][0-9]{2}$/, 'Formato inv√°lido')
        .transform(val => val.toUpperCase()),
});

export type [Nome]Input = z.infer<typeof [Nome]Schema>;
```

### **Exemplo Completo**

```typescript
import { z } from 'zod';

/**
 * üìä Metrics Route Validation Schemas
 *
 * Schemas para valida√ß√£o de rotas de m√©tricas
 */

export class MetricsRouteValidator {
  /**
   * Schema para GET /metrics/session/:sessionId
   * @description Recupera m√©tricas de uma sess√£o espec√≠fica
   */
  static getSessionMetrics() {
    return {
      params: z.object({
        sessionId: z.string().uuid('Session ID must be a valid UUID'),
      }),
    };
  }

  /**
   * Schema para GET /metrics/user/:userId
   * @description Recupera m√©tricas de um usu√°rio espec√≠fico
   */
  static getUserMetrics() {
    return {
      params: z.object({
        userId: z.string().min(1, 'User ID is required'),
      }),
      query: z.object({
        days: z
          .string()
          .optional()
          .refine(val => !val || (!isNaN(Number(val)) && Number(val) > 0), {
            message: 'Days must be a positive number',
          })
          .transform(val => (val ? Number(val) : undefined)),
      }),
    };
  }
}
```

## üìù Tipos de Valida√ß√£o

### **1. Valida√ß√£o de Par√¢metros (`params`)**

```typescript
params: z.object({
  // UUIDs
  id: z.string().uuid('ID must be a valid UUID'),
  sessionId: z.string().uuid('Session ID must be a valid UUID'),

  // IDs num√©ricos
  userId: z.string().min(1, 'User ID is required'),
  prefectureId: z.string().min(1, 'Prefecture ID is required'),

  // Identificadores customizados
  slug: z
    .string()
    .min(1, 'Slug is required')
    .regex(/^[a-z0-9-]+$/, 'Invalid slug format'),
});
```

### **2. Valida√ß√£o de Query Parameters (`query`)**

```typescript
query: z.object({
  // Pagina√ß√£o
  page: z
    .string()
    .optional()
    .refine(val => !val || (!isNaN(Number(val)) && Number(val) > 0), {
      message: 'Page must be a positive number',
    })
    .transform(val => (val ? Number(val) : 1)),

  limit: z
    .string()
    .optional()
    .refine(val => !val || (!isNaN(Number(val)) && Number(val) > 0 && Number(val) <= 100), {
      message: 'Limit must be between 1 and 100',
    })
    .transform(val => (val ? Number(val) : 10)),

  // Filtros
  search: z.string().optional(),
  status: z.enum(['active', 'inactive', 'pending']).optional(),
  category: z.string().min(1, 'Category cannot be empty').optional(),

  // Datas
  startDate: z.string().datetime('Invalid start date format').optional(),
  endDate: z.string().datetime('Invalid end date format').optional(),

  // Ordena√ß√£o
  sortBy: z.enum(['created_at', 'updated_at', 'name']).optional(),
  sortOrder: z.enum(['asc', 'desc']).optional().default('desc'),
});
```

### **3. Valida√ß√£o de Body (`body`)**

```typescript
body: z.object({
  // Campos obrigat√≥rios
  name: z.string().min(1, 'Name is required').max(100, 'Name too long'),
  email: z.string().email('Invalid email format'),

  // Campos opcionais
  description: z.string().max(500, 'Description too long').optional(),
  tags: z.array(z.string().min(1, 'Tag cannot be empty')).optional(),

  // Valida√ß√µes num√©ricas
  age: z.number().int().positive('Age must be positive').optional(),
  price: z.number().positive('Price must be positive').optional(),

  // Valida√ß√µes de data
  birthDate: z.string().datetime('Invalid birth date format').optional(),

  // Valida√ß√µes de enum
  role: z.enum(['user', 'admin', 'moderator']).default('user'),
  status: z.enum(['active', 'inactive']).optional(),

  // Valida√ß√µes de objeto
  address: z
    .object({
      street: z.string().min(1, 'Street is required'),
      city: z.string().min(1, 'City is required'),
      zipCode: z.string().regex(/^\d{5}-?\d{3}$/, 'Invalid ZIP code format'),
      country: z.string().min(2, 'Country code must have 2 characters'),
    })
    .optional(),

  // Valida√ß√µes de array
  permissions: z.array(z.string().min(1, 'Permission cannot be empty')).optional(),
});
```

## üîß Valida√ß√µes Avan√ßadas

### **Transforma√ß√µes de Dados**

```typescript
// Converter string para number
price: z.string()
    .refine((val) => !isNaN(Number(val)) && Number(val) > 0, {
        message: 'Price must be a positive number'
    })
    .transform((val) => Number(val)),

// Converter string para boolean
isActive: z.string()
    .optional()
    .transform((val) => val === 'true' || val === '1'),

// Converter string para array
tags: z.string()
    .optional()
    .transform((val) => val ? val.split(',').map(tag => tag.trim()) : []),

// Normalizar string
name: z.string()
    .min(1, 'Name is required')
    .transform((val) => val.trim().toLowerCase()),
```

### **Valida√ß√µes Customizadas**

```typescript
// Valida√ß√£o de CPF
cpf: z.string()
    .min(11, 'CPF must have at least 11 characters')
    .max(14, 'CPF must have at most 14 characters')
    .refine((val) => {
        const cleanCpf = val.replace(/\D/g, '');
        return /^\d{11}$/.test(cleanCpf);
    }, {
        message: 'Invalid CPF format'
    }),

// Valida√ß√£o de placa de ve√≠culo
plate: z.string()
    .regex(/^[A-Z]{3}[0-9][0-9A-Z][0-9]{2}$/, 'Invalid vehicle plate format')
    .transform((val) => val.toUpperCase()),

// Valida√ß√£o de telefone
phone: z.string()
    .regex(/^\(\d{2}\)\s\d{4,5}-\d{4}$/, 'Invalid phone format')
    .transform((val) => val.replace(/\D/g, '')),

// Valida√ß√£o de senha forte
password: z.string()
    .min(8, 'Password must have at least 8 characters')
    .regex(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]/, {
        message: 'Password must contain uppercase, lowercase, number and special character'
    }),
```

### **Valida√ß√µes Condicionais**

```typescript
// Valida√ß√£o condicional baseada em campo
body: z.object({
  type: z.enum(['individual', 'company']),
  name: z.string().min(1, 'Name is required'),
  document: z.string().min(1, 'Document is required'),
  companyInfo: z
    .object({
      cnpj: z.string().regex(/^\d{2}\.\d{3}\.\d{3}\/\d{4}-\d{2}$/, 'Invalid CNPJ format'),
      companyName: z.string().min(1, 'Company name is required'),
    })
    .optional(),
}).refine(
  data => {
    if (data.type === 'company' && !data.companyInfo) {
      return false;
    }
    return true;
  },
  {
    message: 'Company information is required for company type',
    path: ['companyInfo'],
  }
);

// Valida√ß√£o de data de in√≠cio e fim
body: z.object({
  startDate: z.string().datetime('Invalid start date format'),
  endDate: z.string().datetime('Invalid end date format'),
}).refine(
  data => {
    return new Date(data.startDate) < new Date(data.endDate);
  },
  {
    message: 'Start date must be before end date',
    path: ['endDate'],
  }
);
```

## üìä Schemas por Dom√≠nio

### **Assistant Schema**

```typescript
export class AssistantRouteValidator {
  static postWebhook() {
    return {
      body: z.object({
        session_id: z.string().uuid('Session ID must be a valid UUID'),
        payload: z.object({
          prefeitura_id: z.number().int().positive('Prefecture ID must be positive'),
          prefeitura_sigla: z.string().min(1, 'Prefecture acronym is required'),
          prefeitura_nome: z.string().min(1, 'Prefecture name is required'),
          prefeitura_timezone: z.string().min(1, 'Prefecture timezone is required'),
          usuario_id: z.number().int().positive('User ID must be positive'),
          usuario_nome: z.string().min(1, 'User name is required'),
          usuario_email: z.string().email('Invalid email format'),
          usuario_cpf: z.string().min(11, 'CPF must have at least 11 characters'),
        }),
        prefecture_user_token: z.string().min(1, 'Prefecture user token is required'),
        user_token: z.string().min(1, 'User token is required'),
        message: z.string().min(1, 'Message is required'),
        message_date: z.string().datetime('Invalid message date format'),
        message_date_local: z.string().datetime('Invalid local message date format'),
        assistant_id: z.string().uuid('Assistant ID must be a valid UUID').optional(),
        new_chat: z.boolean().optional(),
      }),
    };
  }
}
```

### **Metrics Schema**

```typescript
export class MetricsRouteValidator {
  static getSessionMetrics() {
    return {
      params: z.object({
        sessionId: z.string().uuid('Session ID must be a valid UUID'),
      }),
    };
  }

  static getUserMetrics() {
    return {
      params: z.object({
        userId: z.string().min(1, 'User ID is required'),
      }),
      query: z.object({
        days: z
          .string()
          .optional()
          .refine(val => !val || (!isNaN(Number(val)) && Number(val) > 0), {
            message: 'Days must be a positive number',
          })
          .transform(val => (val ? Number(val) : undefined)),
      }),
    };
  }
}
```

## ‚úÖ Boas Pr√°ticas

### **1. Nomenclatura**

- **Classes**: `[Nome]RouteSchema` (PascalCase)
- **M√©todos**: `[verbo][Recurso]()` (camelCase)
- **Arquivos**: `[nome].schema.ts` (kebab-case)

### **2. Documenta√ß√£o**

- Sempre documentar o prop√≥sito de cada schema
- Incluir descri√ß√£o da funcionalidade
- Comentar valida√ß√µes complexas

### **3. Organiza√ß√£o**

- Um schema por dom√≠nio funcional
- M√©todos agrupados por opera√ß√£o
- Valida√ß√µes reutiliz√°veis em `shared.validator.ts`

### **4. Valida√ß√µes**

- Usar mensagens de erro descritivas
- Aplicar transforma√ß√µes quando necess√°rio
- Validar limites de neg√≥cio
- Considerar performance

### **5. Type Safety**

- Sempre usar tipos espec√≠ficos
- Evitar `any` e `unknown`
- Aproveitar infer√™ncia do Zod
- Exportar tipos quando necess√°rio

## üîÑ Migra√ß√£o e Evolu√ß√£o

### **Versionamento de Schemas**

```typescript
export class UserRouteValidator {
  // v1 - Schema original
  static createUser() {
    return {
      body: z.object({
        name: z.string().min(1, 'Name is required'),
        email: z.string().email('Invalid email format'),
      }),
    };
  }

  // v2 - Schema com novos campos
  static createUserV2() {
    return {
      body: z.object({
        name: z.string().min(1, 'Name is required'),
        email: z.string().email('Invalid email format'),
        phone: z.string().optional(),
        address: z
          .object({
            street: z.string().min(1, 'Street is required'),
            city: z.string().min(1, 'City is required'),
          })
          .optional(),
      }),
    };
  }
}
```

### **Depreca√ß√£o de Schemas**

```typescript
export class UserRouteValidator {
  /**
   * @deprecated Use createUserV2 instead
   */
  static createUser() {
    // Schema antigo mantido para compatibilidade
  }
}
```

## üéØ Conclus√£o

O padr√£o de **Schemas** oferece:

- ‚úÖ **Valida√ß√£o robusta** de entrada
- ‚úÖ **Type safety** completo
- ‚úÖ **Mensagens de erro** claras
- ‚úÖ **Transforma√ß√µes** autom√°ticas
- ‚úÖ **Organiza√ß√£o** clara por dom√≠nio
- ‚úÖ **Manutenibilidade** alta
- ‚úÖ **Reutiliza√ß√£o** de valida√ß√µes

Este padr√£o garante que todas as rotas HTTP tenham valida√ß√£o consistente e type-safe, melhorando significativamente a qualidade e confiabilidade da API.

---

_Este guia deve ser seguido para todos os novos schemas e atualizado conforme necess√°rio._
