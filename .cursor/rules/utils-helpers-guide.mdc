---
alwaysApply: false
description: Guia Completo de Utils & Helpers - Utilit√°rios e Fun√ß√µes Auxiliares
---

# üîß Guia Completo de Utils & Helpers - Utilit√°rios e Fun√ß√µes Auxiliares

## üìã Resumo Executivo

Este documento descreve o padr√£o arquitetural para Utils e Helpers no projeto Pare Azul API Intelligence. Os Utils s√£o **fun√ß√µes utilit√°rias puras** e **classes est√°ticas** para opera√ß√µes comuns, enquanto os Helpers s√£o **wrappers especializados** para integra√ß√µes externas e configura√ß√µes espec√≠ficas.

## üéØ Prop√≥sito dos Utils & Helpers

### **1. Utils - Fun√ß√µes Utilit√°rias**

- **Opera√ß√µes puras** sem efeitos colaterais
- **Fun√ß√µes reutiliz√°veis** em toda a aplica√ß√£o
- **Classes est√°ticas** com m√©todos utilit√°rios
- **Valida√ß√£o e transforma√ß√£o** de dados

### **2. Helpers - Wrappers Especializados**

- **Configura√ß√µes espec√≠ficas** para servi√ßos externos
- **Wrappers** para bibliotecas de terceiros
- **Inst√¢ncias pr√©-configuradas** para uso direto
- **Abstra√ß√£o** de complexidade de integra√ß√£o

### **3. Separa√ß√£o de Responsabilidades**

- **Utils**: L√≥gica pura e reutiliz√°vel
- **Helpers**: Configura√ß√£o e integra√ß√£o
- **Services**: L√≥gica de neg√≥cio
- **Controllers**: Orquestra√ß√£o HTTP

## üèóÔ∏è Estrutura Padr√£o

### **1. Organiza√ß√£o de Arquivos**

```
src/
‚îú‚îÄ‚îÄ üîß utils/                    # Utilit√°rios puros
‚îÇ   ‚îú‚îÄ‚îÄ logger.util.ts           # Sistema de logging
‚îÇ   ‚îú‚îÄ‚îÄ validation.util.ts       # Valida√ß√£o e sanitiza√ß√£o
‚îÇ   ‚îú‚îÄ‚îÄ http.util.ts            # Cliente HTTP gen√©rico
‚îÇ   ‚îú‚îÄ‚îÄ redis.util.ts           # Opera√ß√µes Redis
‚îÇ   ‚îú‚îÄ‚îÄ crypto.util.ts          # Criptografia e IDs
‚îÇ   ‚îú‚îÄ‚îÄ vector-search.util.ts   # Busca vetorial
‚îÇ   ‚îú‚îÄ‚îÄ activation.utils.ts     # Utilit√°rios de ativa√ß√£o
‚îÇ   ‚îú‚îÄ‚îÄ string.util.ts          # Manipula√ß√£o de strings
‚îÇ   ‚îî‚îÄ‚îÄ supabase.util.ts        # Utilit√°rios Supabase
‚îî‚îÄ‚îÄ üõ†Ô∏è helpers/                 # Helpers especializados
    ‚îî‚îÄ‚îÄ axiosWebservice.ts      # Cliente Axios configurado
```

### **2. Conven√ß√µes de Nomenclatura**

```typescript
// ‚úÖ UTILS: PascalCase com sufixo "Util"
export class ValidationUtil {}
export class CryptoUtil {}
export class RedisUtil {}

// ‚úÖ HELPERS: camelCase descritivo
export const axiosWebservice = axios.create({});
export const httpClient = new HttpUtil({});

// ‚úÖ FUN√á√ïES: camelCase descritivo
export function searchVectors(query: string) {}
export function parseActivationBody(input: ActivateVehicleParams) {}
```

## üîß Padr√µes de Utils

### **1. Classe Est√°tica**

```typescript
// src/utils/[domain].util.ts
export class [Domain]Util {
  /**
   * Descri√ß√£o da fun√ß√£o
   */
  static [methodName](param1: type1, param2: type2): returnType {
    // Implementa√ß√£o
  }

  /**
   * Fun√ß√£o com tratamento de erro
   */
  static async [asyncMethod](param: type): Promise<returnType> {
    try {
      // Implementa√ß√£o
      return result;
    } catch (error) {
      logger.error('[Domain]Util error:', error);
      return defaultValue;
    }
  }
}
```

### **2. Fun√ß√µes Puras**

```typescript
// src/utils/[domain].utils.ts
export function [functionName](input: InputType): OutputType {
  // Transforma√ß√£o pura
  return transformedData;
}

export async function [asyncFunction](input: InputType): Promise<OutputType> {
  // Opera√ß√£o ass√≠ncrona
  return result;
}
```

### **3. Exemplo Implementado - ValidationUtil**

```typescript
// src/utils/validation.util.ts
export class ValidationUtil {
  /**
   * Validar dados usando schema Zod
   */
  static validate<T>(
    schema: z.ZodSchema<T>,
    data: unknown
  ): { success: true; data: T } | { success: false; errors: string[] } {
    try {
      const result = schema.safeParse(data);

      if (result.success) {
        return { success: true, data: result.data };
      } else {
        const errors = result.error.issues.map(
          (err: any) => `${err.path.join('.')}: ${err.message}`
        );
        return { success: false, errors };
      }
    } catch (error) {
      logger.error('Validation error:', error);
      return { success: false, errors: ['Validation failed'] };
    }
  }

  /**
   * Sanitizar HTML b√°sico (remove tags perigosas)
   */
  static sanitizeHtml(input: string): string {
    return input
      .replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '')
      .replace(/<iframe\b[^<]*(?:(?!<\/iframe>)<[^<]*)*<\/iframe>/gi, '')
      .replace(/javascript:/gi, '')
      .replace(/on\w+="[^"]*"/gi, '');
  }

  /**
   * Validar email
   */
  static isValidEmail(email: string): boolean {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email);
  }
}
```

## üõ†Ô∏è Padr√µes de Helpers

### **1. Wrapper Especializado**

```typescript
// src/helpers/[service].ts
import [library] from '[library]';
import { logger } from '../utils/logger.util';
import { env } from '../config/environment.config';

const [service]Logger = logger.child({ service: '[Service]Helper' });

const [service]Instance = [library].create({
  // Configura√ß√£o espec√≠fica
  baseURL: env.[SERVICE]_API_URL,
  timeout: 30000,
  headers: {
    'Content-Type': 'application/json',
    'User-Agent': 'Pareazul-Assistant-Server/1.0',
  },
});

// Interceptors espec√≠ficos
[service]Instance.interceptors.request.use(request => {
  // Headers espec√≠ficos
  if (!request.headers['Custom-Header']) {
    request.headers['Custom-Header'] = 'value';
  }

  [service]Logger.debug(`Making request to: ${request.url}`);
  return request;
});

export default [service]Instance;
```

### **2. Exemplo Implementado - AxiosWebservice**

```typescript
// src/helpers/axiosWebservice.ts
import axios from 'axios';
import { logger } from '../utils/logger.util';
import { env } from '../config/environment.config';

const axiosLogger = logger.child({ service: 'AxiosHelper' });

const axiosWebservice = axios.create({
  baseURL: env.PAREAZUL_API_WEBSERVICE,
});

axiosWebservice.interceptors.request.use(request => {
  if (!request.headers['Origem-Movimento']) {
    request.headers['Origem-Movimento'] = 'APP';
  }

  axiosLogger.debug(`Making request to: ${request.url}`);
  return request;
});

export default axiosWebservice;
```

## üìä Exemplos Implementados

### **1. Logger Util**

```typescript
// src/utils/logger.util.ts
import winston from 'winston';
import { env } from '../config/environment.config';

const logFormat = winston.format.combine(
  winston.format.timestamp(),
  winston.format.errors({ stack: true }),
  winston.format.json()
);

export const logger = winston.createLogger({
  level: env.NODE_ENV === 'production' ? 'info' : 'debug',
  format: logFormat,
  defaultMeta: { service: 'pareazul-assistant-server' },
  transports: [
    new winston.transports.Console({
      format: winston.format.combine(winston.format.colorize(), winston.format.simple()),
    }),
    new winston.transports.File({
      filename: 'logs/error.log',
      level: 'error',
    }),
    new winston.transports.File({
      filename: 'logs/combined.log',
    }),
  ],
});

// Create logs directory if it doesn't exist
import { mkdirSync } from 'fs';
try {
  mkdirSync('logs', { recursive: true });
} catch (error) {
  // Directory already exists
}
```

### **2. HTTP Util**

```typescript
// src/utils/http.util.ts
export class HttpUtil {
  private client: AxiosInstance;
  private retries: number;
  private retryDelay: number;

  constructor(config: HttpClientConfig = {}) {
    this.retries = config.retries || 3;
    this.retryDelay = config.retryDelay || 1000;

    this.client = axios.create({
      baseURL: config.baseURL,
      timeout: config.timeout || 30000,
      headers: {
        'Content-Type': 'application/json',
        'User-Agent': 'Pareazul-Assistant-Server/1.0',
        ...config.headers,
      },
    });

    this.setupInterceptors();
  }

  private setupInterceptors(): void {
    // Request interceptor
    this.client.interceptors.request.use(
      config => {
        logger.debug(`HTTP Request: ${config.method?.toUpperCase()} ${config.url}`, {
          headers: config.headers,
          data: config.data,
        });
        return config;
      },
      error => {
        logger.error('HTTP Request Error:', error);
        return Promise.reject(error);
      }
    );

    // Response interceptor with retry logic
    this.client.interceptors.response.use(
      response => {
        logger.debug(`HTTP Response: ${response.status} ${response.config.url}`, {
          status: response.status,
          headers: response.headers,
          data: response.data,
        });
        return response;
      },
      async error => {
        const config = error.config;

        // Retry logic
        if (config && !config._retry && this.shouldRetry(error)) {
          config._retry = true;
          config._retryCount = (config._retryCount || 0) + 1;

          if (config._retryCount <= this.retries) {
            logger.warn(
              `HTTP Retry attempt ${config._retryCount}/${this.retries} for ${config.url}`
            );

            await this.delay(this.retryDelay * config._retryCount);
            return this.client(config);
          }
        }

        logger.error('HTTP Response Error:', {
          url: error.config?.url,
          method: error.config?.method,
          status: error.response?.status,
          message: error.message,
          data: error.response?.data,
        });

        return Promise.reject(error);
      }
    );
  }

  // HTTP Methods
  async get<T = any>(url: string, config?: AxiosRequestConfig): Promise<AxiosResponse<T>> {
    return this.client.get(url, config);
  }

  async post<T = any>(
    url: string,
    data?: any,
    config?: AxiosRequestConfig
  ): Promise<AxiosResponse<T>> {
    return this.client.post(url, data, config);
  }
}

// Default instance for general use
export const httpClient = new HttpUtil();

// Factory for creating specialized clients
export const createHttpClient = (config: HttpClientConfig): HttpUtil => {
  return new HttpUtil(config);
};
```

### **3. Redis Util**

```typescript
// src/utils/redis.util.ts
export class RedisUtil {
  // Session operations
  static async setSession(key: string, value: any, ttl: number = 3600): Promise<boolean> {
    try {
      await redis.setEx(key, ttl, JSON.stringify(value));
      return true;
    } catch (error) {
      logger.error('Redis setSession error:', error);
      return false;
    }
  }

  static async getSession(key: string): Promise<any | null> {
    try {
      const value = await redis.get(key);
      return value ? JSON.parse(value) : null;
    } catch (error) {
      logger.error('Redis getSession error:', error);
      return null;
    }
  }

  // Memory buffer operations
  static async pushToBuffer(key: string, message: any, maxLength: number = 20): Promise<boolean> {
    try {
      await redis.lPush(key, JSON.stringify(message));
      await redis.lTrim(key, 0, maxLength - 1);
      await redis.expire(key, 3600); // 1 hour TTL
      return true;
    } catch (error) {
      logger.error('Redis pushToBuffer error:', error);
      return false;
    }
  }

  static async getBuffer(key: string, limit: number = 10): Promise<any[]> {
    try {
      const messages = await redis.lRange(key, 0, limit - 1);
      return messages.map(msg => JSON.parse(msg));
    } catch (error) {
      logger.error('Redis getBuffer error:', error);
      return [];
    }
  }

  // Health check
  static async ping(): Promise<boolean> {
    try {
      const result = await redis.ping();
      return result === 'PONG';
    } catch (error) {
      logger.error('Redis ping error:', error);
      return false;
    }
  }
}
```

### **4. Vector Search Util**

```typescript
// src/utils/vector-search.util.ts
export async function searchVectors(query: string): Promise<string> {
  try {
    logger.info(`[VectorSearch] Searching for: "${query}"`);

    // Gera embedding da query
    const embeddingResponse = await openai.embeddings.create({
      model: 'text-embedding-3-small',
      input: query,
    });

    const embedding = embeddingResponse.data[0].embedding;

    // Consulta no Supabase usando a fun√ß√£o RPC
    const { data, error } = await supabaseAdmin.rpc('match_faq', {
      query_embedding: embedding,
      match_threshold: 0.75,
      match_count: 3,
    });

    if (error) {
      logger.error('[VectorSearch] Error in RPC call:', error);
      return '';
    }

    if (!data || data.length === 0) {
      logger.info('[VectorSearch] No matching results found');
      return '';
    }

    const results = data.map((d: any) => d.answer).join('\n\n');
    logger.info(`[VectorSearch] Found ${data.length} matching results`);

    return results;
  } catch (error) {
    logger.error('[VectorSearch] Error searching vectors:', error);
    return '';
  }
}
```

## üéØ Melhores Pr√°ticas

### **1. Nomenclatura**

```typescript
// ‚úÖ BOM: Nomes descritivos e consistentes
export class ValidationUtil {}
export class CryptoUtil {}
export class RedisUtil {}

// ‚ùå RUIM: Nomes gen√©ricos ou inconsistentes
export class Utils {}
export class Helper {}
export class Common {}
```

### **2. Organiza√ß√£o**

```typescript
// ‚úÖ BOM: Agrupamento por funcionalidade
export class ValidationUtil {
  static validate() {}
  static sanitize() {}
  static isValidEmail() {}
}

// ‚ùå RUIM: Mistura de funcionalidades
export class ValidationUtil {
  static validate() {}
  static hash() {}
  static sendEmail() {}
}
```

### **3. Error Handling**

```typescript
// ‚úÖ BOM: Error handling consistente
static async method(): Promise<boolean> {
  try {
    // Implementa√ß√£o
    return true;
  } catch (error) {
    logger.error('Method error:', error);
    return false;
  }
}

// ‚ùå RUIM: Sem tratamento de erro
static async method(): Promise<any> {
  // Implementa√ß√£o sem try/catch
  return result;
}
```

### **4. Logging**

```typescript
// ‚úÖ BOM: Logging estruturado
logger.info(`[VectorSearch] Searching for: "${query}"`);
logger.error('[VectorSearch] Error in RPC call:', error);

// ‚ùå RUIM: Logging gen√©rico
console.log('Searching...');
console.error('Error');
```

### **5. Configura√ß√£o**

```typescript
// ‚úÖ BOM: Configura√ß√£o centralizada
const axiosWebservice = axios.create({
  baseURL: env.PAREAZUL_API_WEBSERVICE,
});

// ‚ùå RUIM: Configura√ß√£o hardcoded
const axiosWebservice = axios.create({
  baseURL: 'https://api.example.com',
});
```

## üîÑ Fluxo de Execu√ß√£o

### **1. Utils**

```
Service/Controller ‚Üí Util Method ‚Üí Pure Function ‚Üí Result
```

### **2. Helpers**

```
Service/Controller ‚Üí Helper Instance ‚Üí External Service ‚Üí Response
```

### **3. Error Flow**

```
Util/Helper ‚Üí Error Handling ‚Üí Logging ‚Üí Fallback Value
```

## üöÄ Vantagens da Arquitetura

### **1. Reutiliza√ß√£o**

- **Fun√ß√µes puras** reutiliz√°veis
- **Classes est√°ticas** sem instancia√ß√£o
- **Configura√ß√µes** centralizadas

### **2. Manutenibilidade**

- **Separa√ß√£o clara** de responsabilidades
- **C√≥digo limpo** e test√°vel
- **Error handling** consistente

### **3. Testabilidade**

- **Fun√ß√µes puras** f√°ceis de testar
- **Dependency injection** clara
- **Mocking** simplificado

### **4. Performance**

- **Inst√¢ncias reutiliz√°veis** de helpers
- **Configura√ß√£o otimizada** de clientes
- **Caching** inteligente

## üìà Recomenda√ß√µes de Melhoria

### **1. Base Util Class**

```typescript
// src/utils/base.util.ts
export abstract class BaseUtil {
  protected static logger = logger.child({ util: this.constructor.name });

  protected static handleError(error: unknown, context: string): void {
    this.logger.error(`${context}:`, error);
  }

  protected static validateInput<T>(input: T, validator: (input: T) => boolean): T {
    if (!validator(input)) {
      throw new Error(`Invalid input: ${JSON.stringify(input)}`);
    }
    return input;
  }
}
```

### **2. Util Factory**

```typescript
// src/utils/util.factory.ts
export class UtilFactory {
  static createHttpClient(config: HttpClientConfig): HttpUtil {
    return new HttpUtil(config);
  }

  static createRedisClient(config: RedisConfig): RedisUtil {
    return new RedisUtil(config);
  }

  static createLogger(service: string): winston.Logger {
    return logger.child({ service });
  }
}
```

### **3. Helper Registry**

```typescript
// src/helpers/registry.ts
export class HelperRegistry {
  private static instances = new Map<string, any>();

  static register<T>(name: string, instance: T): void {
    this.instances.set(name, instance);
  }

  static get<T>(name: string): T {
    const instance = this.instances.get(name);
    if (!instance) {
      throw new Error(`Helper ${name} not found`);
    }
    return instance;
  }

  static has(name: string): boolean {
    return this.instances.has(name);
  }
}
```

### **4. Util Testing**

```typescript
// src/utils/__tests__/validation.util.test.ts
describe('ValidationUtil', () => {
  describe('validate', () => {
    it('should validate data successfully', () => {
      const schema = z.object({ name: z.string() });
      const data = { name: 'test' };

      const result = ValidationUtil.validate(schema, data);

      expect(result.success).toBe(true);
      expect(result.data).toEqual(data);
    });

    it('should return errors for invalid data', () => {
      const schema = z.object({ name: z.string() });
      const data = { name: 123 };

      const result = ValidationUtil.validate(schema, data);

      expect(result.success).toBe(false);
      expect(result.errors).toHaveLength(1);
    });
  });
});
```

## üéØ Conclus√£o

A arquitetura de Utils & Helpers no projeto est√° bem estruturada e segue padr√µes consistentes. O uso de **classes est√°ticas** para utils, **wrappers especializados** para helpers, **error handling** robusto e **logging estruturado** garante c√≥digo limpo, reutiliz√°vel e maint√≠vel.

As principais melhorias seriam implementar **Base Util Class**, **Util Factory**, **Helper Registry** e **testes automatizados** para tornar o sistema ainda mais robusto e consistente.

---

_Este guia deve ser atualizado conforme a evolu√ß√£o do projeto e descobertas de melhores pr√°ticas._
