---
alwaysApply: false
description: Guia Completo de APIs - Integra√ß√µes Externas
---

# üåê Guia Completo de APIs - Integra√ß√µes Externas

## üìã Resumo Executivo

Este documento descreve o padr√£o arquitetural para APIs no projeto Pare Azul API Intelligence. As APIs s√£o respons√°veis por integrar com servi√ßos externos do Pareazul, fornecendo uma camada de abstra√ß√£o limpa e consistente para comunica√ß√£o HTTP.

## üéØ Prop√≥sito das APIs

### **1. Integra√ß√£o Externa**

- **Comunica√ß√£o HTTP** com servi√ßos Pareazul
- **Abstra√ß√£o de endpoints** externos
- **Padroniza√ß√£o de requests/responses**

### **2. Camada de Dados**

- **Transforma√ß√£o de dados** entre formatos
- **Valida√ß√£o de responses** externas
- **Tratamento de erros** espec√≠ficos

### **3. Reutiliza√ß√£o**

- **Fun√ß√µes puras** e reutiliz√°veis
- **Interface consistente** para services
- **Facilita testes** e mocking

## üèóÔ∏è Estrutura Padr√£o

### **1. Template Base**

```typescript
// src/api/[domain].api.ts
import axiosWebservice from "../helpers/axiosWebservice";
import { logger as loggerUtil } from "../utils/logger.util";
import { [DomainType] } from "../types/[domain].types";

const logger = loggerUtil.child({ service: '[Domain]Api' });

export const [functionName] = async (
    param1: string,
    param2: string,
    // ... outros par√¢metros
): Promise<[ReturnType]> => {
    const path = `/v4/[endpoint]/[path]`;

    return axiosWebservice.get(path, {
        headers: { 'x-access-key': token },
    })
        .then(response => {
            // Valida√ß√£o e transforma√ß√£o de dados
            if (!response.data || !Array.isArray(response.data)) {
                return [];
            }

            const { data } = response;
            return data.map(item => transformData(item));
        })
        .catch(error => {
            logger.error("[functionName] Error:", error);
            throw error;
        });
};
```

### **2. Padr√µes Obrigat√≥rios**

```typescript
// ‚úÖ SEMPRE usar Promise ao inv√©s de try/catch
export const fetchData = async (): Promise<DataType[]> => {
  return axiosWebservice
    .get('/endpoint')
    .then(response => {
      // Processamento dos dados
      return response.data;
    })
    .catch(error => {
      logger.error('[fetchData] Error:', error);
      throw error;
    });
};

// ‚ùå NUNCA usar try/catch em APIs
export const fetchDataWrong = async (): Promise<DataType[]> => {
  try {
    const response = await axiosWebservice.get('/endpoint');
    return response.data;
  } catch (error) {
    logger.error('[fetchDataWrong] Error:', error);
    throw error;
  }
};
```

## üîß Componentes Obrigat√≥rios

### **1. Imports Padr√£o**

```typescript
// Imports obrigat√≥rios para todas as APIs
import axiosWebservice from "../helpers/axiosWebservice";
import { logger as loggerUtil } from "../utils/logger.util";
import { [DomainType] } from "../types/[domain].types";

// Logger espec√≠fico do dom√≠nio
const logger = loggerUtil.child({ service: '[Domain]Api' });
```

### **2. Estrutura de Fun√ß√£o**

```typescript
export const functionName = async (
  // Par√¢metros tipados
  param1: string,
  param2: string,
  token: string
): Promise<ReturnType> => {
  // 1. Constru√ß√£o do path
  const path = `/v4/[endpoint]/[path]`;

  // 2. Chamada HTTP
  return axiosWebservice
    .get(path, {
      headers: { 'x-access-key': token },
    })
    .then(response => {
      // 3. Valida√ß√£o de dados
      if (!response.data || !Array.isArray(response.data)) {
        return [];
      }

      // 4. Transforma√ß√£o de dados
      const { data } = response;
      return data.map(item => transformData(item));
    })
    .catch(error => {
      // 5. Log e re-throw
      logger.error('[functionName] Error:', error);
      throw error;
    });
};
```

### **3. Headers Padr√£o**

```typescript
// Headers obrigat√≥rios para Pareazul APIs
const headers = {
  'x-access-key': token, // Token de autentica√ß√£o
  'Content-Type': 'application/json', // Para POST/PUT
};
```

## üìä Tipos de APIs Implementadas

### **1. Activation API**

```typescript
// src/api/activation.api.ts
export const fetchVehicleCurrentActivations = async (
  plate: string,
  prefectureId: string,
  timezone: string,
  prefectureToken: string
): Promise<VehicleActivation[]> => {
  const path = `/v4/prefeituras/${prefectureId}/ativacoes/validas?placa=${plate}`;

  return axiosWebservice
    .get(path, {
      headers: { 'x-access-key': prefectureToken },
    })
    .then(response => {
      if (!response.data || !Array.isArray(response.data)) {
        return [];
      }

      const { data: activations } = response;
      const orderedActivations = activations.sort((a, b) => {
        return (
          new Date(b.data_inicio_ativacao).getTime() - new Date(a.data_inicio_ativacao).getTime()
        );
      });

      return orderedActivations.map(activation => {
        return extractActivationData(activation, timezone);
      });
    })
    .catch(error => {
      logger.error('[fetchVehicleCurrentActivations] Error:', error);
      throw error;
    });
};
```

**Caracter√≠sticas:**

- **Ordena√ß√£o de dados** por data
- **Transforma√ß√£o** com utils espec√≠ficos
- **Valida√ß√£o** de array de dados

### **2. Vehicle API**

```typescript
// src/api/vehicle.api.ts
export const fetchUserVehicles = (userId: string, prefectureToken: string) =>
  new Promise<APIVehicle[]>((resolve, reject) => {
    const path = `/v4/usuarios/${userId}/veiculos`;

    return axiosWebservice
      .get(path, {
        headers: { 'x-access-key': prefectureToken },
      })
      .then(response => {
        if (response.status !== 200) {
          return [];
        }

        const vehicles: Vehicle[] = response.data;
        if (!Array.isArray(vehicles)) {
          return [];
        }

        const parsedVehicles: APIVehicle[] = vehicles.map(v => ({
          plate: v.placa,
          model: v.modelo.toLowerCase(),
          vehicle_type: v.tipo_veiculo,
          vehicle_type_id: v.tipo_veiculo_id,
        }));

        return parsedVehicles;
      })
      .then(resolve)
      .catch(error => {
        const errorMessage = error.response?.data?.message || error.message || error;
        reject(errorMessage);
      });
  });
```

**Caracter√≠sticas:**

- **Promise expl√≠cita** com resolve/reject
- **Mapeamento de dados** para formato interno
- **Tratamento de status** HTTP

### **3. Prefecture API**

```typescript
// src/api/prefecture.api.ts
export const fetchPrefectureRules = (prefectureId: string, prefectureToken: string) =>
  new Promise<Rule[]>((resolve, reject) => {
    const path = `/v4/prefeituras/${prefectureId}/regras`;

    return axiosWebservice
      .get(path, {
        headers: { 'x-access-key': prefectureToken },
      })
      .then(response => {
        const { data: rules } = response;

        if (!Array.isArray(rules) || rules.length === 0) {
          throw new Error('No rules found for prefecture.');
        }

        return rules;
      })
      .then(resolve)
      .catch(error => {
        const errorMessage = error.response?.data?.message || error.message || error;
        logger.error('[fetchPrefectureRules] Error:', error);
        reject(errorMessage);
      });
  });
```

**Caracter√≠sticas:**

- **Valida√ß√£o de dados** obrigat√≥rios
- **Error handling** espec√≠fico
- **Promise pattern** com resolve/reject

## üéØ Melhores Pr√°ticas

### **1. Nomenclatura**

```typescript
// ‚úÖ BOM: Nomes descritivos e consistentes
export const fetchVehicleCurrentActivations = async () => {};
export const activateVehicle = async () => {};
export const fetchUserVehicles = async () => {};

// ‚ùå RUIM: Nomes gen√©ricos ou inconsistentes
export const getData = async () => {};
export const fetchVehicles = async () => {};
export const activate = async () => {};
```

### **2. Tipagem**

```typescript
// ‚úÖ BOM: Tipos expl√≠citos e espec√≠ficos
export const fetchData = async (userId: string, token: string): Promise<VehicleActivation[]> => {};

// ‚ùå RUIM: Tipos gen√©ricos ou any
export const fetchData = async (userId: any, token: any): Promise<any> => {};
```

### **3. Error Handling**

```typescript
// ‚úÖ BOM: Log espec√≠fico e re-throw
.catch(error => {
    logger.error("[functionName] Error:", error);
    throw error;
});

// ‚ùå RUIM: Log gen√©rico ou tratamento inadequado
.catch(error => {
    console.log("Error:", error);
    return null;
});
```

### **4. Valida√ß√£o de Dados**

```typescript
// ‚úÖ BOM: Valida√ß√£o robusta
.then(response => {
    if (!response.data || !Array.isArray(response.data)) {
        return [];
    }

    const { data } = response;
    return data.map(item => transformData(item));
});

// ‚ùå RUIM: Sem valida√ß√£o
.then(response => {
    return response.data.map(item => transformData(item));
});
```

## üîÑ Fluxo de Execu√ß√£o

### **1. Chamada de API**

```
Service ‚Üí API Function ‚Üí axiosWebservice ‚Üí External Service
```

### **2. Processamento**

```
External Response ‚Üí Validation ‚Üí Transformation ‚Üí Return
```

### **3. Error Flow**

```
Error ‚Üí Log ‚Üí Re-throw ‚Üí Service Error Handling
```

## üöÄ Vantagens da Arquitetura

### **1. Consist√™ncia**

- **Padr√£o uniforme** em todas as APIs
- **Headers padronizados** para Pareazul
- **Error handling** consistente

### **2. Reutiliza√ß√£o**

- **Fun√ß√µes puras** e test√°veis
- **Interface clara** para services
- **Facilita mocking** em testes

### **3. Manutenibilidade**

- **Separa√ß√£o clara** de responsabilidades
- **Logging estruturado** por dom√≠nio
- **Tipagem forte** em toda a cadeia

### **4. Performance**

- **Promise pattern** otimizado
- **Valida√ß√£o eficiente** de dados
- **Cache-friendly** design

## üìà Recomenda√ß√µes de Melhoria

### **1. API Client Factory**

```typescript
// Criar factory para diferentes tipos de cliente
class APIClientFactory {
  static createPareazulClient(token: string) {
    return axios.create({
      baseURL: process.env.PAREAZUL_API_URL,
      headers: { 'x-access-key': token },
      timeout: 30000,
    });
  }
}
```

### **2. Response Interceptors**

```typescript
// Interceptor para padronizar responses
axiosWebservice.interceptors.response.use(
  response => {
    // Valida√ß√£o autom√°tica de response
    if (!response.data) {
      throw new Error('Empty response from API');
    }
    return response;
  },
  error => {
    // Log autom√°tico de erros
    logger.error('API Error:', error);
    return Promise.reject(error);
  }
);
```

### **3. Retry Logic**

```typescript
// Implementar retry autom√°tico para falhas tempor√°rias
const retryRequest = async (fn: () => Promise<any>, retries = 3) => {
  for (let i = 0; i < retries; i++) {
    try {
      return await fn();
    } catch (error) {
      if (i === retries - 1) throw error;
      await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)));
    }
  }
};
```

## üéØ Conclus√£o

A arquitetura de APIs no projeto est√° bem estruturada e segue padr√µes consistentes. O uso de **Promise pattern** ao inv√©s de try/catch, **tipagem forte**, **logging estruturado** e **valida√ß√£o robusta** garante c√≥digo limpo e maint√≠vel.

As principais melhorias seriam implementar **API Client Factory**, **Response Interceptors** e **Retry Logic** para tornar o sistema ainda mais robusto.

---

_Este guia deve ser atualizado conforme a evolu√ß√£o do projeto e descobertas de melhores pr√°ticas._
