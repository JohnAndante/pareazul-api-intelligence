---
description: Guia Completo de Agentes LangChain
alwaysApply: false
---

# ü§ñ Guia Completo de Agentes LangChain

## üìã Vis√£o Geral

Este documento explica detalhadamente como funcionam os agentes LangChain, suas depend√™ncias, configura√ß√µes, sistema de mem√≥ria e como as tools s√£o anexadas, baseado na implementa√ß√£o do projeto Pare Azul API Intelligence.

## üèóÔ∏è Arquitetura de um Agente LangChain

### Componentes Fundamentais

Um agente LangChain √© composto por:

```typescript
// Componentes principais
- LLM (Large Language Model)    // C√©rebro do agente
- Tools (Ferramentas)           // Capacidades do agente
- Prompt Template               // Instru√ß√µes e contexto
- Agent Executor                // Orquestrador principal
- Memory (Opcional)             // Mem√≥ria de conversas
```

### Fluxo de Execu√ß√£o

```mermaid
graph TD
    A[Input do Usu√°rio] --> B[Agent Executor]
    B --> C[LLM + Prompt]
    C --> D[Precisa usar Tool?]
    D --> E[Sim]
    E --> F[Seleciona Tool]
    F --> G[Executa Tool]
    G --> H[N√£o]
    H --> I[Resposta Direta]
    I --> J[Retorna Resultado]
    J --> K[LLM Processa]
    K --> L[Resposta Final]
```

## üîß Configura√ß√£o Detalhada

### 1. Configura√ß√£o do LLM

```typescript
// src/agents/assistant/agent.ts
const llm = new ChatOpenAI({
  modelName: 'gpt-4o-mini', // Modelo espec√≠fico
  temperature: 0.3, // Criatividade (0-1)
  topP: 0.9, // Nucleus sampling
  openAIApiKey: process.env.OPENAI_API_KEY,
  maxTokens: 4000, // Limite de tokens
  timeout: 30000, // Timeout em ms
});
```

**Par√¢metros importantes:**

- **`temperature`**: Controla a aleatoriedade (0 = determin√≠stico, 1 = muito criativo)
- **`topP`**: Nucleus sampling - considera apenas os tokens mais prov√°veis
- **`maxTokens`**: Limite m√°ximo de tokens na resposta
- **`timeout`**: Tempo limite para a requisi√ß√£o

### 2. Sistema de Prompts Din√¢micos

```typescript
// src/agents/assistant/prompt.ts
const createDynamicPrompt = (payload: any) => {
  const currentDate = new Date().toISOString();

  // Processa o prompt completamente antes de usar
  const systemPrompt = createPromptTemplate(payload, currentDate);

  return ChatPromptTemplate.fromMessages([
    ['system', systemPrompt], // Instru√ß√µes do sistema
    ['human', '{input}'], // Input do usu√°rio
    ['placeholder', '{agent_scratchpad}'], // Rascunho do agente
  ]);
};
```

**Estrutura do Prompt:**

- **System Message**: Instru√ß√µes permanentes, regras de comportamento
- **Human Message**: Input do usu√°rio atual
- **Agent Scratchpad**: Hist√≥rico de a√ß√µes e observa√ß√µes

### 3. Cria√ß√£o do Agente

```typescript
// src/agents/assistant/agent.ts
export const createAssistantAgent = async (payload: any) => {
  const promptTemplate = createDynamicPrompt(payload);
  const tools = createAllTools(); // Todas as tools dispon√≠veis

  const agent = await createOpenAIToolsAgent({
    llm, // Modelo de linguagem
    tools, // Ferramentas dispon√≠veis
    prompt: promptTemplate, // Template de prompt
  });

  return new AgentExecutor({
    agent, // Agente criado
    tools, // Mesmas tools
    verbose: process.env.NODE_ENV === 'development',
    returnIntermediateSteps: process.env.NODE_ENV === 'development',
    maxIterations: 12, // M√°ximo de itera√ß√µes
    earlyStoppingMethod: 'generate', // M√©todo de parada antecipada
    handleParsingErrors: true, // Trata erros de parsing
  });
};
```

## üõ†Ô∏è Sistema de Tools

### 1. Estrutura de uma Tool

```typescript
// src/tools/faq.tool.ts
export const faqSearchTool = new DynamicStructuredTool({
  name: 'faq_search', // Nome √∫nico da tool
  description: 'Search for frequently asked questions...', // Descri√ß√£o para o LLM
  schema: FaqSearchSchema, // Schema Zod para valida√ß√£o
  func: async ({ query }) => {
    // Fun√ß√£o de execu√ß√£o
    try {
      const results = await searchVectors(query);
      return results || 'No relevant FAQ entries found.';
    } catch (error) {
      return 'Error searching FAQ database.';
    }
  },
});
```

### 2. Como as Tools s√£o Anexadas

```typescript
// src/tools/index.ts
export function createAllTools() {
  return [
    ...activationTools, // Tools de ativa√ß√£o
    ...databaseTools, // Tools de banco de dados
    ...faqTools, // Tools de FAQ
  ];
}

// src/agents/assistant/agent.ts
const tools = createAllTools(); // Agrega todas as tools
const agent = await createOpenAIToolsAgent({
  llm,
  tools, // Passa as tools para o agente
  prompt: promptTemplate,
});
```

### 3. Processo de Sele√ß√£o de Tools

1. **LLM analisa** o input do usu√°rio
2. **Identifica** se precisa de informa√ß√µes externas
3. **Seleciona** a tool mais apropriada baseada na descri√ß√£o
4. **Chama** a tool com os par√¢metros corretos
5. **Processa** o resultado da tool
6. **Gera** resposta final incorporando os dados

## üß† Sistema de Mem√≥ria

### 1. Mem√≥ria H√≠brida (Redis + Supabase)

```typescript
// src/services/memory.service.ts
export class MemoryService {
  // Cache de sess√£o no Redis
  async setSessionCache(userId: string, sessionData: SessionCache): Promise<boolean> {
    const key = `chat_assistente_${userId}`;
    await redis.setEx(key, this.SESSION_TTL, JSON.stringify(sessionData));
  }

  // Buffer de mem√≥ria para mensagens recentes
  async setMemoryBuffer(sessionId: string, messages: ChatMessage[]): Promise<boolean> {
    const key = `memory_buffer_${sessionId}`;
    const buffer: MemoryBuffer = {
      messages: messages.map(msg => ({
        role: msg.subject,
        content: msg.content,
        timestamp: msg.created_at,
      })),
      maxSize: this.BUFFER_SIZE,
    };
    await redis.setEx(key, this.SESSION_TTL, JSON.stringify(buffer));
  }
}
```

### 2. Integra√ß√£o com o Agente

```typescript
// src/agents/assistant/index.ts
export async function processAssistantMessage(message: string, payload: ChatPayload) {
  // 1. Processa sess√£o
  const sessionResult = await sessionService.createSession({ payload });

  // 2. Registra mensagem do usu√°rio
  await memoryService.addMessage(session.id, 'user', message);

  // 3. Invoca agente com contexto
  const agentResponse = await invokeAssistantAgent(message, context);

  // 4. Registra resposta do agente
  await memoryService.addMessage(session.id, 'assistant', agentResponse);

  // 5. Atualiza cache da sess√£o
  await memoryService.setSessionCache(userId, sessionData);
}
```

## üîÑ Fluxo Completo de Execu√ß√£o

### 1. Entrada e Valida√ß√£o

```typescript
// Controller recebe requisi√ß√£o
const { message, payload, assistant_id } = req.body;

// Valida entrada
const validatedInput = AssistantQuerySchema.parse({
  message,
  payload,
  assistant_id,
});
```

### 2. Gerenciamento de Sess√£o

```typescript
// Verifica se existe sess√£o ativa
const sessionResult = await sessionService.createSession({
  payload: validatedInput.payload,
  assistant_id: validatedInput.assistant_id,
});

// Cria contexto para o agente
const context: AgentContext = {
  sessionId: session.id,
  userId: payload.usuario_id,
  prefectureId: payload.prefeitura_id,
  payload: payload,
  metadata: { isNewSession, sessionCreatedAt: session.created_at },
};
```

### 3. Execu√ß√£o do Agente

```typescript
// src/agents/assistant/agent.ts
export const invokeAssistantAgent = async (input: string, context: AgentContext) => {
  // Cria agente com payload espec√≠fico
  const agentExecutor = await createAssistantAgent(context.payload);

  // Invoca agente
  const result = await agentExecutor.invoke({
    input: input, // Mensagem do usu√°rio
    currentDate: new Date().toISOString(), // Data atual
    context: JSON.stringify(context), // Contexto da sess√£o
  });

  return result.output;
};
```

### 4. Processamento de Tools

```typescript
// Quando o LLM decide usar uma tool
{
    "tool": "faq_search",
    "toolInput": {
        "query": "internet para usar o aplicativo"
    },
    "toolCallId": "call_NL7c5eKTtq3Vx2AkwJPwnS2a"
}

// A tool √© executada
const results = await searchVectors(query);

// Resultado √© retornado para o LLM
"Here are some relevant FAQ entries that might help:\n\nSim, √© necess√°rio ter conex√£o..."
```

## ‚öôÔ∏è Configura√ß√µes Avan√ßadas

### 1. Agent Executor

```typescript
new AgentExecutor({
  agent, // Agente criado
  tools, // Tools dispon√≠veis
  verbose: true, // Log detalhado
  returnIntermediateSteps: true, // Retorna passos intermedi√°rios
  maxIterations: 12, // M√°ximo de itera√ß√µes
  earlyStoppingMethod: 'generate', // Para quando gera resposta
  handleParsingErrors: true, // Trata erros de parsing
});
```

### 2. Tratamento de Erros

```typescript
// src/agents/assistant/agent.ts
try {
  const result = await agentExecutor.invoke(input);
  return result.output;
} catch (error) {
  if (error.message.includes('timeout')) {
    return 'Desculpe, houve um timeout ao processar sua solicita√ß√£o.';
  }
  if (error.message.includes('rate limit')) {
    return 'Desculpe, estou com muitas solicita√ß√µes no momento.';
  }
  return 'Desculpe, houve um erro interno.';
}
```

## üìä Monitoramento e Logging

### 1. Logging Estruturado

```typescript
// Winston logger com contexto
logger.info(`[AssistantAgent] Processing message: "${message}"`);
logger.debug(`[AssistantAgent] Context:`, context);
logger.info(`[AssistantAgent] Response generated successfully`);
```

### 2. M√©tricas de Performance

```typescript
// Token usage tracking
{
    "tokenUsage": {
        "promptTokens": 2388,
        "completionTokens": 48,
        "totalTokens": 2436
    },
    "finish_reason": "stop",
    "model_name": "gpt-4o-mini-2024-07-18"
}
```

## üéØ Vantagens desta Arquitetura

### 1. Modularidade

- Tools independentes e reutiliz√°veis
- F√°cil adicionar novas capacidades
- Separa√ß√£o clara de responsabilidades

### 2. Flexibilidade

- Prompts din√¢micos baseados no contexto
- Tools podem ser ativadas/desativadas
- Configura√ß√µes ajust√°veis por ambiente

### 3. Robustez

- Tratamento de erros em m√∫ltiplas camadas
- Fallbacks para falhas de tools
- Timeout e rate limiting

### 4. Observabilidade

- Logging detalhado em cada etapa
- M√©tricas de performance
- Rastreamento de tokens e custos

## üîç Exemplo Pr√°tico de Execu√ß√£o

### Log de Execu√ß√£o Real

```json
{
  "intermediateSteps": [
    {
      "action": {
        "tool": "faq_search",
        "toolInput": {
          "query": "internet para usar o aplicativo"
        },
        "toolCallId": "call_NL7c5eKTtq3Vx2AkwJPwnS2a"
      },
      "observation": "Here are some relevant FAQ entries that might help:\n\nSim, √© necess√°rio ter conex√£o com a internet (Wi-Fi ou dados m√≥veis) para fazer login, ativar o estacionamento, verificar o status das ativa√ß√µes e receber notifica√ß√µes."
    }
  ],
  "output": "Sim, √© necess√°rio ter conex√£o com a internet (Wi-Fi ou dados m√≥veis) para fazer login, ativar o estacionamento, verificar o status das ativa√ß√µes e receber notifica√ß√µes. Se precisar de mais alguma informa√ß√£o, estou √† disposi√ß√£o!"
}
```

### An√°lise do Log

1. **Input**: "Preciso de internet para usar o aplicativo?"
2. **LLM Decision**: Identificou que precisa buscar na FAQ
3. **Tool Call**: Executou `faq_search` com query "internet para usar o aplicativo"
4. **Tool Result**: Retornou resposta da base de conhecimento
5. **Final Output**: Resposta final incorporando os dados da FAQ

## üöÄ Melhores Pr√°ticas

### 1. Design de Tools

- **Nomes descritivos** e √∫nicos
- **Descri√ß√µes claras** para o LLM entender quando usar
- **Valida√ß√£o robusta** com schemas Zod
- **Error handling** consistente

### 2. Configura√ß√£o de Prompts

- **Instru√ß√µes claras** sobre quando usar cada tool
- **Exemplos pr√°ticos** de intera√ß√£o
- **Contexto din√¢mico** baseado no payload
- **Fallbacks** para situa√ß√µes inesperadas

### 3. Gerenciamento de Mem√≥ria

- **Cache inteligente** para performance
- **Persist√™ncia** para hist√≥rico
- **TTL apropriado** para dados tempor√°rios
- **Fallback graceful** quando Redis n√£o est√° dispon√≠vel

### 4. Monitoramento

- **Logging estruturado** em cada etapa
- **M√©tricas de performance** (tokens, tempo)
- **Rastreamento de erros** detalhado
- **Alertas** para falhas cr√≠ticas

---

_Este guia deve ser atualizado conforme a evolu√ß√£o do projeto e descobertas de melhores pr√°ticas._
