---
alwaysApply: false
description: Guia Completo de Valida√ß√£o - Entradas, Sa√≠das e Tipagens
---

# üîç Validation Guide - Guia Completo de Valida√ß√£o

## üìã Resumo Executivo

Este guia define o padr√£o de valida√ß√£o de entradas, sa√≠das e tipagens no projeto Pare Azul API Intelligence. O sistema utiliza **Zod schemas** para valida√ß√£o de tools LangChain, services e APIs, garantindo type safety e valida√ß√£o robusta em toda a aplica√ß√£o.

## üéØ Estrutura de Valida√ß√£o

### **Organiza√ß√£o de Arquivos**

```
src/
‚îú‚îÄ‚îÄ schemas/                    # Schemas Zod para tools/services
‚îÇ   ‚îú‚îÄ‚îÄ activation.schema.ts    # Schemas de ativa√ß√µes
‚îÇ   ‚îú‚îÄ‚îÄ database.schema.ts      # Schemas de banco de dados
‚îÇ   ‚îú‚îÄ‚îÄ faq.schema.ts           # Schemas de FAQ
‚îÇ   ‚îú‚îÄ‚îÄ notification.schema.ts  # Schemas de notifica√ß√µes
‚îÇ   ‚îú‚îÄ‚îÄ prefecture.schema.ts    # Schemas de prefeitura
‚îÇ   ‚îú‚îÄ‚îÄ shared.schema.ts        # Schemas compartilhados
‚îÇ   ‚îú‚îÄ‚îÄ user.schema.ts          # Schemas de usu√°rios
‚îÇ   ‚îî‚îÄ‚îÄ vehicle.schema.ts       # Schemas de ve√≠culos
‚îú‚îÄ‚îÄ validators/                 # Validadores de rotas HTTP
‚îÇ   ‚îú‚îÄ‚îÄ assistant.validator.ts  # Valida√ß√£o das rotas do assistant
‚îÇ   ‚îî‚îÄ‚îÄ metrics.validator.ts    # Valida√ß√£o das rotas de m√©tricas
‚îî‚îÄ‚îÄ types/                      # Defini√ß√µes de tipos TypeScript
    ‚îú‚îÄ‚îÄ chat.types.ts
    ‚îú‚îÄ‚îÄ user.types.ts
    ‚îî‚îÄ‚îÄ metrics.types.ts
```

### **Diferen√ßa entre Schemas e Validators**

| **Schemas** (`src/schemas/`)           | **Validators** (`src/validators/`)       |
| -------------------------------------- | ---------------------------------------- |
| ‚úÖ **Schemas Zod** para tools/services | ‚úÖ **Validadores** de rotas HTTP         |
| ‚úÖ Inputs de fun√ß√µes e services        | ‚úÖ `req.body`, `req.params`, `req.query` |
| ‚úÖ Valida√ß√£o para tools e APIs         | ‚úÖ Valida√ß√£o inline nas rotas            |
| ‚úÖ Schemas Zod exportados              | ‚úÖ Classes com m√©todos est√°ticos         |

## üèóÔ∏è Padr√£o de Schemas

### **Estrutura Base**

```typescript
import { z } from 'zod';
import {
    userIdValidator,
    vehiclePlateValidator
} from './shared.schema';

/**
 * [Nome] Schemas
 *
 * Schemas Zod para [funcionalidade]
 */

export const [Nome]Schema = z.object({
    // Campos obrigat√≥rios
    campoObrigatorio: z.string().min(1, 'Campo obrigat√≥rio'),

    // Campos opcionais
    campoOpcional: z.string().optional(),

    // Valida√ß√µes customizadas
    campoCustomizado: z.string()
        .regex(/^[A-Z]{3}[0-9][0-9A-Z][0-9]{2}$/, 'Formato inv√°lido')
        .transform(val => val.toUpperCase()),

    // Usando validadores compartilhados
    userId: userIdValidator,
    vehiclePlate: vehiclePlateValidator,
});

export type [Nome]Input = z.infer<typeof [Nome]Schema>;
```

### **Exemplo Completo**

```typescript
// src/schemas/activation.schema.ts
import { z } from 'zod';
import { userIdValidator, vehiclePlateValidator } from './shared.schema';

export const CheckVehicleActivationSchema = z.object({
  userId: userIdValidator,
  vehiclePlate: vehiclePlateValidator,
});

export const RegisterVehicleActivationSchema = z.object({
  userId: userIdValidator,
  vehiclePlate: vehiclePlateValidator,

  timeValueRuleId: z
    .number()
    .int('Time value rule ID must be an integer')
    .positive('Time value rule ID must be positive')
    .describe('The time value rule ID'),

  previousActivationId: z
    .number()
    .int('Previous activation ID must be an integer')
    .positive('Previous activation ID must be positive')
    .optional()
    .describe('The previous activation ID (optional)'),

  extend: z.boolean().describe('Whether this is an extension of a previous activation'),
});

export type CheckVehicleActivationInput = z.infer<typeof CheckVehicleActivationSchema>;
export type RegisterVehicleActivationInput = z.infer<typeof RegisterVehicleActivationSchema>;
```

## üìù Tipos de Valida√ß√£o

### **1. Valida√ß√£o de Entrada (Input Validation)**

```typescript
// Valida√ß√£o b√°sica
export const BasicValidator = z.object({
  name: z.string().min(1, 'Name is required'),
  email: z.string().email('Invalid email format'),
  age: z.number().int().positive('Age must be positive'),
});

// Valida√ß√£o com transforma√ß√µes
export const TransformValidator = z.object({
  plate: z
    .string()
    .regex(/^[A-Z]{3}[0-9][0-9A-Z][0-9]{2}$/, 'Invalid plate format')
    .transform(val => val.toUpperCase()),

  phone: z
    .string()
    .regex(/^\(\d{2}\)\s\d{4,5}-\d{4}$/, 'Invalid phone format')
    .transform(val => val.replace(/\D/g, '')),
});

// Valida√ß√£o condicional
export const ConditionalValidator = z
  .object({
    type: z.enum(['individual', 'company']),
    name: z.string().min(1, 'Name is required'),
    companyInfo: z
      .object({
        cnpj: z.string().regex(/^\d{2}\.\d{3}\.\d{3}\/\d{4}-\d{2}$/, 'Invalid CNPJ'),
        companyName: z.string().min(1, 'Company name is required'),
      })
      .optional(),
  })
  .refine(
    data => {
      if (data.type === 'company' && !data.companyInfo) {
        return false;
      }
      return true;
    },
    {
      message: 'Company information is required for company type',
      path: ['companyInfo'],
    }
  );
```

### **2. Valida√ß√£o de Sa√≠da (Output Validation)**

```typescript
// Valida√ß√£o de resposta de API
export const ApiResponseValidator = z.object({
  success: z.boolean(),
  data: z.any().optional(),
  error: z.string().optional(),
  timestamp: z.string().datetime(),
});

// Valida√ß√£o de dados de banco
export const DatabaseRecordValidator = z.object({
  id: z.string().uuid(),
  created_at: z.string().datetime(),
  updated_at: z.string().datetime(),
  is_active: z.boolean(),
});

// Valida√ß√£o de resposta de service
export const ServiceResponseValidator = z.object({
  text: z.string().min(1, 'Response text is required'),
  data: z.any().optional(),
  success: z.boolean().default(true),
});
```

### **3. Valida√ß√£o de Tipos (Type Validation)**

```typescript
// Valida√ß√£o de enums
export const StatusValidator = z.enum(['active', 'inactive', 'pending']);

// Valida√ß√£o de arrays
export const TagsValidator = z
  .array(z.string().min(1, 'Tag cannot be empty'))
  .min(1, 'At least one tag is required');

// Valida√ß√£o de objetos aninhados
export const AddressValidator = z.object({
  street: z.string().min(1, 'Street is required'),
  city: z.string().min(1, 'City is required'),
  zipCode: z.string().regex(/^\d{5}-?\d{3}$/, 'Invalid ZIP code'),
  country: z.string().min(2, 'Country code must have 2 characters'),
});

// Valida√ß√£o de uni√£o de tipos
export const IdValidator = z.union([z.string().uuid(), z.number().int().positive()]);
```

## üîß Validadores Compartilhados

### **Estrutura do shared.schema.ts**

```typescript
import { z } from 'zod';

/**
 * Schemas compartilhados para evitar repeti√ß√£o de valida√ß√µes
 * Padr√µes comuns usados em m√∫ltiplos validators
 */

/**
 * @name userIdValidator
 * @description The unique identifier for the user
 * @example 1234567890
 */
export const userIdValidator = z
  .number()
  .int('User ID must be an integer')
  .positive('User ID must be positive')
  .min(1, 'User ID is required')
  .describe('The unique identifier for the user');

/**
 * @name vehiclePlateValidator
 * @description The plate of the vehicle
 * @example 'ABC1234' or 'ABC1D23'
 */
export const vehiclePlateValidator = z
  .string()
  .trim()
  .toUpperCase()
  .regex(/^[A-Z]{3}[0-9][0-9A-Z][0-9]{2}$/, 'Vehicle plate must be a valid plate number')
  .min(7, 'Vehicle plate must be at least 7 characters')
  .max(8, 'Vehicle plate must be at most 8 characters')
  .describe('The plate of the vehicle');

/**
 * @name emailValidator
 * @description Email address validation
 * @example 'user@example.com'
 */
export const emailValidator = z
  .string()
  .email('Invalid email format')
  .min(1, 'Email is required')
  .describe('Email address');

/**
 * @name phoneValidator
 * @description Phone number validation
 * @example '(11) 99999-9999'
 */
export const phoneValidator = z
  .string()
  .regex(/^\(\d{2}\)\s\d{4,5}-\d{4}$/, 'Invalid phone format')
  .transform(val => val.replace(/\D/g, ''))
  .describe('Phone number');

/**
 * @name cpfValidator
 * @description CPF validation
 * @example '123.456.789-00'
 */
export const cpfValidator = z
  .string()
  .min(11, 'CPF must have at least 11 characters')
  .max(14, 'CPF must have at most 14 characters')
  .refine(
    val => {
      const cleanCpf = val.replace(/\D/g, '');
      return /^\d{11}$/.test(cleanCpf);
    },
    {
      message: 'Invalid CPF format',
    }
  )
  .describe('CPF number');
```

### **Uso dos Validadores Compartilhados**

```typescript
import { z } from 'zod';
import {
  userIdValidator,
  vehiclePlateValidator,
  emailValidator,
  phoneValidator,
  cpfValidator,
} from './shared.schema';

export const UserValidator = z.object({
  userId: userIdValidator,
  email: emailValidator,
  phone: phoneValidator.optional(),
  cpf: cpfValidator.optional(),
});

export const VehicleValidator = z.object({
  userId: userIdValidator,
  plate: vehiclePlateValidator,
  model: z.string().min(1, 'Model is required'),
  year: z
    .number()
    .int()
    .min(1900)
    .max(new Date().getFullYear() + 1),
});
```

## üìä Valida√ß√£o por Dom√≠nio

### **1. Activation Validators**

```typescript
// src/schemas/activation.schema.ts
export const CheckVehicleActivationSchema = z.object({
  userId: userIdValidator,
  vehiclePlate: vehiclePlateValidator,
});

export const RegisterVehicleActivationSchema = z.object({
  userId: userIdValidator,
  vehiclePlate: vehiclePlateValidator,
  timeValueRuleId: z.number().int().positive('Time value rule ID must be positive'),
  previousActivationId: z.number().int().positive().optional(),
  extend: z.boolean(),
});
```

### **2. User Validators**

```typescript
// src/schemas/user.schema.ts
export const GetUserBalanceSchema = z.object({
  userId: userIdValidator,
});

export const UpdateUserValidator = z.object({
  userId: userIdValidator,
  name: z.string().min(1, 'Name is required').optional(),
  email: emailValidator.optional(),
  phone: phoneValidator.optional(),
});
```

### **3. Vehicle Validators**

```typescript
// src/schemas/vehicle.schema.ts
export const GetUserVehiclesSchema = z.object({
  userId: userIdValidator,
  plate: vehiclePlateValidator.optional(),
  model: z.string().trim().toLowerCase().optional(),
});

export const RegisterUserVehicleSchema = z.object({
  userId: userIdValidator,
  vehicle: z.object({
    plate: vehiclePlateValidator,
    model: z
      .string()
      .trim()
      .regex(/^[a-zA-Z√°√†√¢√£√©√®√™√≠√Ø√≥√¥√µ√∂√∫√ß√±√Å√Ä√Ç√É√â√à√ä√ç√è√ì√í√ñ√ö√á√ë0-9- ]+$/, 'Invalid model format'),
    vehicle_type_id: z
      .number()
      .int()
      .positive()
      .refine(id => [1, 2, 3].includes(id), 'Invalid vehicle type'),
  }),
});
```

### **4. Notification Validators**

```typescript
// src/schemas/notification.schema.ts
export const GetAllUserVehiclesCurrentNotificationsSchema = z.object({
  userId: userIdValidator,
});

export const GetCurrentNotificationsForVehicleSchema = z.object({
  userId: userIdValidator,
  vehiclePlate: vehiclePlateValidator,
});
```

### **5. Database Validators**

```typescript
// src/schemas/database.schema.ts
export const GetUserInfoSchema = z.object({
  userId: userIdValidator,
});

export const GetMessageHistorySchema = z.object({
  sessionId: z.string().uuid('Session ID must be a valid UUID'),
  limit: z.number().int().positive().optional().default(20),
});

export const GetSessionStatusSchema = z.object({
  sessionId: z.string().uuid('Session ID must be a valid UUID'),
});
```

## üîß Valida√ß√µes Avan√ßadas

### **1. Valida√ß√£o de Arrays**

```typescript
// Array de strings
export const TagsValidator = z
  .array(z.string().min(1, 'Tag cannot be empty'))
  .min(1, 'At least one tag is required')
  .max(10, 'Maximum 10 tags allowed');

// Array de objetos
export const ItemsValidator = z
  .array(
    z.object({
      id: z.string().uuid(),
      name: z.string().min(1, 'Name is required'),
      quantity: z.number().int().positive('Quantity must be positive'),
    })
  )
  .min(1, 'At least one item is required');
```

### **2. Valida√ß√£o de Objetos Aninhados**

```typescript
export const UserProfileValidator = z.object({
  personalInfo: z.object({
    name: z.string().min(1, 'Name is required'),
    email: emailValidator,
    phone: phoneValidator.optional(),
  }),
  address: z
    .object({
      street: z.string().min(1, 'Street is required'),
      city: z.string().min(1, 'City is required'),
      zipCode: z.string().regex(/^\d{5}-?\d{3}$/, 'Invalid ZIP code'),
      country: z.string().min(2, 'Country code must have 2 characters'),
    })
    .optional(),
  preferences: z
    .object({
      notifications: z.boolean().default(true),
      language: z.enum(['pt', 'en', 'es']).default('pt'),
      theme: z.enum(['light', 'dark']).default('light'),
    })
    .optional(),
});
```

### **3. Valida√ß√£o de Uni√£o de Tipos**

```typescript
export const IdValidator = z.union([
  z.string().uuid('Invalid UUID format'),
  z.number().int().positive('Invalid numeric ID'),
]);

export const StatusValidator = z.union([
  z.literal('active'),
  z.literal('inactive'),
  z.literal('pending'),
  z.literal('cancelled'),
]);
```

### **4. Valida√ß√£o com Transforma√ß√µes**

```typescript
export const DataTransformerValidator = z.object({
  // Converter string para number
  price: z
    .string()
    .refine(val => !isNaN(Number(val)) && Number(val) > 0, {
      message: 'Price must be a positive number',
    })
    .transform(val => Number(val)),

  // Converter string para boolean
  isActive: z
    .string()
    .optional()
    .transform(val => val === 'true' || val === '1'),

  // Normalizar string
  name: z
    .string()
    .min(1, 'Name is required')
    .transform(val => val.trim().toLowerCase()),

  // Converter string para array
  tags: z
    .string()
    .optional()
    .transform(val => (val ? val.split(',').map(tag => tag.trim()) : [])),
});
```

## üö® Tratamento de Erros

### **Mensagens de Erro Personalizadas**

```typescript
export const CustomErrorValidator = z.object({
  email: z
    .string()
    .min(1, 'Email √© obrigat√≥rio')
    .email('Formato de email inv√°lido')
    .max(100, 'Email deve ter no m√°ximo 100 caracteres'),

  age: z
    .number()
    .int('Idade deve ser um n√∫mero inteiro')
    .positive('Idade deve ser positiva')
    .min(18, 'Idade m√≠nima √© 18 anos')
    .max(120, 'Idade m√°xima √© 120 anos'),

  password: z
    .string()
    .min(8, 'Senha deve ter pelo menos 8 caracteres')
    .regex(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/, 'Senha deve conter mai√∫scula, min√∫scula e n√∫mero'),
});
```

### **Valida√ß√£o de Erros Customizados**

```typescript
export const BusinessRuleValidator = z
  .object({
    startDate: z.string().datetime('Data de in√≠cio inv√°lida'),
    endDate: z.string().datetime('Data de fim inv√°lida'),
    budget: z.number().positive('Or√ßamento deve ser positivo'),
  })
  .refine(
    data => {
      return new Date(data.startDate) < new Date(data.endDate);
    },
    {
      message: 'Data de in√≠cio deve ser anterior √† data de fim',
      path: ['endDate'],
    }
  )
  .refine(
    data => {
      return data.budget > 1000;
    },
    {
      message: 'Or√ßamento m√≠nimo √© R$ 1.000,00',
      path: ['budget'],
    }
  );
```

## üìä Exemplos de Uso

### **1. Em Tools LangChain**

```typescript
// src/tools/activation.tools.ts
import { DynamicStructuredTool } from '@langchain/core/tools';
import { CheckVehicleActivationSchema } from '../validators/activation.validator';

export const checkVehicleActivationTool = new DynamicStructuredTool({
  name: 'checkVehicleCurrentActivations',
  description: 'Check current activations for a vehicle',
  schema: CheckVehicleActivationSchema,
  func: async ({ userId, vehiclePlate }) => {
    // Implementa√ß√£o da tool
    return await activationService.checkCurrentVehicleActivation({
      userId,
      vehiclePlate,
    });
  },
});
```

### **2. Em Services**

```typescript
// src/services/user.service.ts
import { GetUserBalanceSchema } from '../validators/user.validator';

export class UserService {
  async getUserBalance(input: unknown) {
    // Validar entrada
    const validatedInput = GetUserBalanceSchema.parse(input);

    // Processar com dados validados
    const { userId } = validatedInput;
    return await this.fetchUserBalance(userId);
  }
}
```

### **3. Em APIs**

```typescript
// src/api/user.api.ts
import { GetUserBalanceSchema } from '../validators/user.validator';

export async function fetchUserBalance(input: unknown) {
  // Validar entrada
  const validatedInput = GetUserBalanceSchema.parse(input);

  // Fazer chamada para API externa
  const response = await axios.post('/api/user/balance', validatedInput);

  // Validar resposta
  const validatedResponse = ApiResponseValidator.parse(response.data);

  return validatedResponse;
}
```

## ‚úÖ Boas Pr√°ticas

### **1. Nomenclatura**

- **Validators**: `[Nome]Validator` (PascalCase)
- **Types**: `[Nome]Input` ou `[Nome]Output` (PascalCase)
- **Arquivos**: `[nome].validator.ts` (kebab-case)

### **2. Organiza√ß√£o**

- Um validator por dom√≠nio funcional
- Validadores compartilhados em `shared.schema.ts`
- Tipos exportados junto com validators
- Documenta√ß√£o clara de cada validator

### **3. Valida√ß√µes**

- Usar mensagens de erro descritivas
- Aplicar transforma√ß√µes quando necess√°rio
- Validar limites de neg√≥cio
- Considerar performance

### **4. Reutiliza√ß√£o**

- Criar validadores compartilhados para padr√µes comuns
- Evitar duplica√ß√£o de valida√ß√µes
- Manter consist√™ncia entre validators
- Documentar depend√™ncias entre validators

### **5. Type Safety**

- Sempre exportar tipos inferidos
- Usar tipos espec√≠ficos
- Evitar `any` e `unknown`
- Aproveitar infer√™ncia do Zod

## üîÑ Migra√ß√£o e Evolu√ß√£o

### **Versionamento de Validators**

```typescript
export class UserValidator {
  // v1 - Validator original
  static createUser() {
    return z.object({
      name: z.string().min(1, 'Name is required'),
      email: z.string().email('Invalid email format'),
    });
  }

  // v2 - Validator com novos campos
  static createUserV2() {
    return z.object({
      name: z.string().min(1, 'Name is required'),
      email: z.string().email('Invalid email format'),
      phone: z.string().optional(),
      address: z
        .object({
          street: z.string().min(1, 'Street is required'),
          city: z.string().min(1, 'City is required'),
        })
        .optional(),
    });
  }
}
```

### **Depreca√ß√£o de Validators**

```typescript
export class UserValidator {
  /**
   * @deprecated Use createUserV2 instead
   */
  static createUser() {
    // Validator antigo mantido para compatibilidade
  }
}
```

## üéØ Conclus√£o

O padr√£o de **Validators** oferece:

- ‚úÖ **Valida√ß√£o robusta** de entradas e sa√≠das
- ‚úÖ **Type safety** completo
- ‚úÖ **Mensagens de erro** claras
- ‚úÖ **Transforma√ß√µes** autom√°ticas
- ‚úÖ **Reutiliza√ß√£o** de valida√ß√µes
- ‚úÖ **Organiza√ß√£o** clara por dom√≠nio
- ‚úÖ **Manutenibilidade** alta

Este padr√£o garante que todas as entradas e sa√≠das de fun√ß√µes tenham valida√ß√£o consistente e type-safe, melhorando significativamente a qualidade e confiabilidade da aplica√ß√£o.

---

_Este guia deve ser seguido para todos os novos validators e atualizado conforme necess√°rio._
