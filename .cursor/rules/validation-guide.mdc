---
alwaysApply: false
description: Guia Completo de Validação - Entradas, Saídas e Tipagens
---

# 🔍 Validation Guide - Guia Completo de Validação

## 📋 Resumo Executivo

Este guia define o padrão de validação de entradas, saídas e tipagens no projeto Pare Azul API Intelligence. O sistema utiliza **Zod schemas** para validação de tools LangChain, services e APIs, garantindo type safety e validação robusta em toda a aplicação.

## 🎯 Estrutura de Validação

### **Organização de Arquivos**

```
src/
├── schemas/                    # Schemas Zod para tools/services
│   ├── activation.schema.ts    # Schemas de ativações
│   ├── database.schema.ts      # Schemas de banco de dados
│   ├── faq.schema.ts           # Schemas de FAQ
│   ├── notification.schema.ts  # Schemas de notificações
│   ├── prefecture.schema.ts    # Schemas de prefeitura
│   ├── shared.schema.ts        # Schemas compartilhados
│   ├── user.schema.ts          # Schemas de usuários
│   └── vehicle.schema.ts       # Schemas de veículos
├── validators/                 # Validadores de rotas HTTP
│   ├── assistant.validator.ts  # Validação das rotas do assistant
│   └── metrics.validator.ts    # Validação das rotas de métricas
└── types/                      # Definições de tipos TypeScript
    ├── chat.types.ts
    ├── user.types.ts
    └── metrics.types.ts
```

### **Diferença entre Schemas e Validators**

| **Schemas** (`src/schemas/`)           | **Validators** (`src/validators/`)       |
| -------------------------------------- | ---------------------------------------- |
| ✅ **Schemas Zod** para tools/services | ✅ **Validadores** de rotas HTTP         |
| ✅ Inputs de funções e services        | ✅ `req.body`, `req.params`, `req.query` |
| ✅ Validação para tools e APIs         | ✅ Validação inline nas rotas            |
| ✅ Schemas Zod exportados              | ✅ Classes com métodos estáticos         |

## 🏗️ Padrão de Schemas

### **Estrutura Base**

```typescript
import { z } from 'zod';
import {
    userIdValidator,
    vehiclePlateValidator
} from './shared.schema';

/**
 * [Nome] Schemas
 *
 * Schemas Zod para [funcionalidade]
 */

export const [Nome]Schema = z.object({
    // Campos obrigatórios
    campoObrigatorio: z.string().min(1, 'Campo obrigatório'),

    // Campos opcionais
    campoOpcional: z.string().optional(),

    // Validações customizadas
    campoCustomizado: z.string()
        .regex(/^[A-Z]{3}[0-9][0-9A-Z][0-9]{2}$/, 'Formato inválido')
        .transform(val => val.toUpperCase()),

    // Usando validadores compartilhados
    userId: userIdValidator,
    vehiclePlate: vehiclePlateValidator,
});

export type [Nome]Input = z.infer<typeof [Nome]Schema>;
```

### **Exemplo Completo**

```typescript
// src/schemas/activation.schema.ts
import { z } from 'zod';
import { userIdValidator, vehiclePlateValidator } from './shared.schema';

export const CheckVehicleActivationSchema = z.object({
  userId: userIdValidator,
  vehiclePlate: vehiclePlateValidator,
});

export const RegisterVehicleActivationSchema = z.object({
  userId: userIdValidator,
  vehiclePlate: vehiclePlateValidator,

  timeValueRuleId: z
    .number()
    .int('Time value rule ID must be an integer')
    .positive('Time value rule ID must be positive')
    .describe('The time value rule ID'),

  previousActivationId: z
    .number()
    .int('Previous activation ID must be an integer')
    .positive('Previous activation ID must be positive')
    .optional()
    .describe('The previous activation ID (optional)'),

  extend: z.boolean().describe('Whether this is an extension of a previous activation'),
});

export type CheckVehicleActivationInput = z.infer<typeof CheckVehicleActivationSchema>;
export type RegisterVehicleActivationInput = z.infer<typeof RegisterVehicleActivationSchema>;
```

## 📝 Tipos de Validação

### **1. Validação de Entrada (Input Validation)**

```typescript
// Validação básica
export const BasicValidator = z.object({
  name: z.string().min(1, 'Name is required'),
  email: z.string().email('Invalid email format'),
  age: z.number().int().positive('Age must be positive'),
});

// Validação com transformações
export const TransformValidator = z.object({
  plate: z
    .string()
    .regex(/^[A-Z]{3}[0-9][0-9A-Z][0-9]{2}$/, 'Invalid plate format')
    .transform(val => val.toUpperCase()),

  phone: z
    .string()
    .regex(/^\(\d{2}\)\s\d{4,5}-\d{4}$/, 'Invalid phone format')
    .transform(val => val.replace(/\D/g, '')),
});

// Validação condicional
export const ConditionalValidator = z
  .object({
    type: z.enum(['individual', 'company']),
    name: z.string().min(1, 'Name is required'),
    companyInfo: z
      .object({
        cnpj: z.string().regex(/^\d{2}\.\d{3}\.\d{3}\/\d{4}-\d{2}$/, 'Invalid CNPJ'),
        companyName: z.string().min(1, 'Company name is required'),
      })
      .optional(),
  })
  .refine(
    data => {
      if (data.type === 'company' && !data.companyInfo) {
        return false;
      }
      return true;
    },
    {
      message: 'Company information is required for company type',
      path: ['companyInfo'],
    }
  );
```

### **2. Validação de Saída (Output Validation)**

```typescript
// Validação de resposta de API
export const ApiResponseValidator = z.object({
  success: z.boolean(),
  data: z.any().optional(),
  error: z.string().optional(),
  timestamp: z.string().datetime(),
});

// Validação de dados de banco
export const DatabaseRecordValidator = z.object({
  id: z.string().uuid(),
  created_at: z.string().datetime(),
  updated_at: z.string().datetime(),
  is_active: z.boolean(),
});

// Validação de resposta de service
export const ServiceResponseValidator = z.object({
  text: z.string().min(1, 'Response text is required'),
  data: z.any().optional(),
  success: z.boolean().default(true),
});
```

### **3. Validação de Tipos (Type Validation)**

```typescript
// Validação de enums
export const StatusValidator = z.enum(['active', 'inactive', 'pending']);

// Validação de arrays
export const TagsValidator = z
  .array(z.string().min(1, 'Tag cannot be empty'))
  .min(1, 'At least one tag is required');

// Validação de objetos aninhados
export const AddressValidator = z.object({
  street: z.string().min(1, 'Street is required'),
  city: z.string().min(1, 'City is required'),
  zipCode: z.string().regex(/^\d{5}-?\d{3}$/, 'Invalid ZIP code'),
  country: z.string().min(2, 'Country code must have 2 characters'),
});

// Validação de união de tipos
export const IdValidator = z.union([z.string().uuid(), z.number().int().positive()]);
```

## 🔧 Validadores Compartilhados

### **Estrutura do shared.schema.ts**

```typescript
import { z } from 'zod';

/**
 * Schemas compartilhados para evitar repetição de validações
 * Padrões comuns usados em múltiplos validators
 */

/**
 * @name userIdValidator
 * @description The unique identifier for the user
 * @example 1234567890
 */
export const userIdValidator = z
  .number()
  .int('User ID must be an integer')
  .positive('User ID must be positive')
  .min(1, 'User ID is required')
  .describe('The unique identifier for the user');

/**
 * @name vehiclePlateValidator
 * @description The plate of the vehicle
 * @example 'ABC1234' or 'ABC1D23'
 */
export const vehiclePlateValidator = z
  .string()
  .trim()
  .toUpperCase()
  .regex(/^[A-Z]{3}[0-9][0-9A-Z][0-9]{2}$/, 'Vehicle plate must be a valid plate number')
  .min(7, 'Vehicle plate must be at least 7 characters')
  .max(8, 'Vehicle plate must be at most 8 characters')
  .describe('The plate of the vehicle');

/**
 * @name emailValidator
 * @description Email address validation
 * @example 'user@example.com'
 */
export const emailValidator = z
  .string()
  .email('Invalid email format')
  .min(1, 'Email is required')
  .describe('Email address');

/**
 * @name phoneValidator
 * @description Phone number validation
 * @example '(11) 99999-9999'
 */
export const phoneValidator = z
  .string()
  .regex(/^\(\d{2}\)\s\d{4,5}-\d{4}$/, 'Invalid phone format')
  .transform(val => val.replace(/\D/g, ''))
  .describe('Phone number');

/**
 * @name cpfValidator
 * @description CPF validation
 * @example '123.456.789-00'
 */
export const cpfValidator = z
  .string()
  .min(11, 'CPF must have at least 11 characters')
  .max(14, 'CPF must have at most 14 characters')
  .refine(
    val => {
      const cleanCpf = val.replace(/\D/g, '');
      return /^\d{11}$/.test(cleanCpf);
    },
    {
      message: 'Invalid CPF format',
    }
  )
  .describe('CPF number');
```

### **Uso dos Validadores Compartilhados**

```typescript
import { z } from 'zod';
import {
  userIdValidator,
  vehiclePlateValidator,
  emailValidator,
  phoneValidator,
  cpfValidator,
} from './shared.schema';

export const UserValidator = z.object({
  userId: userIdValidator,
  email: emailValidator,
  phone: phoneValidator.optional(),
  cpf: cpfValidator.optional(),
});

export const VehicleValidator = z.object({
  userId: userIdValidator,
  plate: vehiclePlateValidator,
  model: z.string().min(1, 'Model is required'),
  year: z
    .number()
    .int()
    .min(1900)
    .max(new Date().getFullYear() + 1),
});
```

## 📊 Validação por Domínio

### **1. Activation Validators**

```typescript
// src/schemas/activation.schema.ts
export const CheckVehicleActivationSchema = z.object({
  userId: userIdValidator,
  vehiclePlate: vehiclePlateValidator,
});

export const RegisterVehicleActivationSchema = z.object({
  userId: userIdValidator,
  vehiclePlate: vehiclePlateValidator,
  timeValueRuleId: z.number().int().positive('Time value rule ID must be positive'),
  previousActivationId: z.number().int().positive().optional(),
  extend: z.boolean(),
});
```

### **2. User Validators**

```typescript
// src/schemas/user.schema.ts
export const GetUserBalanceSchema = z.object({
  userId: userIdValidator,
});

export const UpdateUserValidator = z.object({
  userId: userIdValidator,
  name: z.string().min(1, 'Name is required').optional(),
  email: emailValidator.optional(),
  phone: phoneValidator.optional(),
});
```

### **3. Vehicle Validators**

```typescript
// src/schemas/vehicle.schema.ts
export const GetUserVehiclesSchema = z.object({
  userId: userIdValidator,
  plate: vehiclePlateValidator.optional(),
  model: z.string().trim().toLowerCase().optional(),
});

export const RegisterUserVehicleSchema = z.object({
  userId: userIdValidator,
  vehicle: z.object({
    plate: vehiclePlateValidator,
    model: z
      .string()
      .trim()
      .regex(/^[a-zA-ZáàâãéèêíïóôõöúçñÁÀÂÃÉÈÊÍÏÓÒÖÚÇÑ0-9- ]+$/, 'Invalid model format'),
    vehicle_type_id: z
      .number()
      .int()
      .positive()
      .refine(id => [1, 2, 3].includes(id), 'Invalid vehicle type'),
  }),
});
```

### **4. Notification Validators**

```typescript
// src/schemas/notification.schema.ts
export const GetAllUserVehiclesCurrentNotificationsSchema = z.object({
  userId: userIdValidator,
});

export const GetCurrentNotificationsForVehicleSchema = z.object({
  userId: userIdValidator,
  vehiclePlate: vehiclePlateValidator,
});
```

### **5. Database Validators**

```typescript
// src/schemas/database.schema.ts
export const GetUserInfoSchema = z.object({
  userId: userIdValidator,
});

export const GetMessageHistorySchema = z.object({
  sessionId: z.string().uuid('Session ID must be a valid UUID'),
  limit: z.number().int().positive().optional().default(20),
});

export const GetSessionStatusSchema = z.object({
  sessionId: z.string().uuid('Session ID must be a valid UUID'),
});
```

## 🔧 Validações Avançadas

### **1. Validação de Arrays**

```typescript
// Array de strings
export const TagsValidator = z
  .array(z.string().min(1, 'Tag cannot be empty'))
  .min(1, 'At least one tag is required')
  .max(10, 'Maximum 10 tags allowed');

// Array de objetos
export const ItemsValidator = z
  .array(
    z.object({
      id: z.string().uuid(),
      name: z.string().min(1, 'Name is required'),
      quantity: z.number().int().positive('Quantity must be positive'),
    })
  )
  .min(1, 'At least one item is required');
```

### **2. Validação de Objetos Aninhados**

```typescript
export const UserProfileValidator = z.object({
  personalInfo: z.object({
    name: z.string().min(1, 'Name is required'),
    email: emailValidator,
    phone: phoneValidator.optional(),
  }),
  address: z
    .object({
      street: z.string().min(1, 'Street is required'),
      city: z.string().min(1, 'City is required'),
      zipCode: z.string().regex(/^\d{5}-?\d{3}$/, 'Invalid ZIP code'),
      country: z.string().min(2, 'Country code must have 2 characters'),
    })
    .optional(),
  preferences: z
    .object({
      notifications: z.boolean().default(true),
      language: z.enum(['pt', 'en', 'es']).default('pt'),
      theme: z.enum(['light', 'dark']).default('light'),
    })
    .optional(),
});
```

### **3. Validação de União de Tipos**

```typescript
export const IdValidator = z.union([
  z.string().uuid('Invalid UUID format'),
  z.number().int().positive('Invalid numeric ID'),
]);

export const StatusValidator = z.union([
  z.literal('active'),
  z.literal('inactive'),
  z.literal('pending'),
  z.literal('cancelled'),
]);
```

### **4. Validação com Transformações**

```typescript
export const DataTransformerValidator = z.object({
  // Converter string para number
  price: z
    .string()
    .refine(val => !isNaN(Number(val)) && Number(val) > 0, {
      message: 'Price must be a positive number',
    })
    .transform(val => Number(val)),

  // Converter string para boolean
  isActive: z
    .string()
    .optional()
    .transform(val => val === 'true' || val === '1'),

  // Normalizar string
  name: z
    .string()
    .min(1, 'Name is required')
    .transform(val => val.trim().toLowerCase()),

  // Converter string para array
  tags: z
    .string()
    .optional()
    .transform(val => (val ? val.split(',').map(tag => tag.trim()) : [])),
});
```

## 🚨 Tratamento de Erros

### **Mensagens de Erro Personalizadas**

```typescript
export const CustomErrorValidator = z.object({
  email: z
    .string()
    .min(1, 'Email é obrigatório')
    .email('Formato de email inválido')
    .max(100, 'Email deve ter no máximo 100 caracteres'),

  age: z
    .number()
    .int('Idade deve ser um número inteiro')
    .positive('Idade deve ser positiva')
    .min(18, 'Idade mínima é 18 anos')
    .max(120, 'Idade máxima é 120 anos'),

  password: z
    .string()
    .min(8, 'Senha deve ter pelo menos 8 caracteres')
    .regex(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/, 'Senha deve conter maiúscula, minúscula e número'),
});
```

### **Validação de Erros Customizados**

```typescript
export const BusinessRuleValidator = z
  .object({
    startDate: z.string().datetime('Data de início inválida'),
    endDate: z.string().datetime('Data de fim inválida'),
    budget: z.number().positive('Orçamento deve ser positivo'),
  })
  .refine(
    data => {
      return new Date(data.startDate) < new Date(data.endDate);
    },
    {
      message: 'Data de início deve ser anterior à data de fim',
      path: ['endDate'],
    }
  )
  .refine(
    data => {
      return data.budget > 1000;
    },
    {
      message: 'Orçamento mínimo é R$ 1.000,00',
      path: ['budget'],
    }
  );
```

## 📊 Exemplos de Uso

### **1. Em Tools LangChain**

```typescript
// src/tools/activation.tools.ts
import { DynamicStructuredTool } from '@langchain/core/tools';
import { CheckVehicleActivationSchema } from '../validators/activation.validator';

export const checkVehicleActivationTool = new DynamicStructuredTool({
  name: 'checkVehicleCurrentActivations',
  description: 'Check current activations for a vehicle',
  schema: CheckVehicleActivationSchema,
  func: async ({ userId, vehiclePlate }) => {
    // Implementação da tool
    return await activationService.checkCurrentVehicleActivation({
      userId,
      vehiclePlate,
    });
  },
});
```

### **2. Em Services**

```typescript
// src/services/user.service.ts
import { GetUserBalanceSchema } from '../validators/user.validator';

export class UserService {
  async getUserBalance(input: unknown) {
    // Validar entrada
    const validatedInput = GetUserBalanceSchema.parse(input);

    // Processar com dados validados
    const { userId } = validatedInput;
    return await this.fetchUserBalance(userId);
  }
}
```

### **3. Em APIs**

```typescript
// src/api/user.api.ts
import { GetUserBalanceSchema } from '../validators/user.validator';

export async function fetchUserBalance(input: unknown) {
  // Validar entrada
  const validatedInput = GetUserBalanceSchema.parse(input);

  // Fazer chamada para API externa
  const response = await axios.post('/api/user/balance', validatedInput);

  // Validar resposta
  const validatedResponse = ApiResponseValidator.parse(response.data);

  return validatedResponse;
}
```

## ✅ Boas Práticas

### **1. Nomenclatura**

- **Validators**: `[Nome]Validator` (PascalCase)
- **Types**: `[Nome]Input` ou `[Nome]Output` (PascalCase)
- **Arquivos**: `[nome].validator.ts` (kebab-case)

### **2. Organização**

- Um validator por domínio funcional
- Validadores compartilhados em `shared.schema.ts`
- Tipos exportados junto com validators
- Documentação clara de cada validator

### **3. Validações**

- Usar mensagens de erro descritivas
- Aplicar transformações quando necessário
- Validar limites de negócio
- Considerar performance

### **4. Reutilização**

- Criar validadores compartilhados para padrões comuns
- Evitar duplicação de validações
- Manter consistência entre validators
- Documentar dependências entre validators

### **5. Type Safety**

- Sempre exportar tipos inferidos
- Usar tipos específicos
- Evitar `any` e `unknown`
- Aproveitar inferência do Zod

## 🔄 Migração e Evolução

### **Versionamento de Validators**

```typescript
export class UserValidator {
  // v1 - Validator original
  static createUser() {
    return z.object({
      name: z.string().min(1, 'Name is required'),
      email: z.string().email('Invalid email format'),
    });
  }

  // v2 - Validator com novos campos
  static createUserV2() {
    return z.object({
      name: z.string().min(1, 'Name is required'),
      email: z.string().email('Invalid email format'),
      phone: z.string().optional(),
      address: z
        .object({
          street: z.string().min(1, 'Street is required'),
          city: z.string().min(1, 'City is required'),
        })
        .optional(),
    });
  }
}
```

### **Deprecação de Validators**

```typescript
export class UserValidator {
  /**
   * @deprecated Use createUserV2 instead
   */
  static createUser() {
    // Validator antigo mantido para compatibilidade
  }
}
```

## 🎯 Conclusão

O padrão de **Validators** oferece:

- ✅ **Validação robusta** de entradas e saídas
- ✅ **Type safety** completo
- ✅ **Mensagens de erro** claras
- ✅ **Transformações** automáticas
- ✅ **Reutilização** de validações
- ✅ **Organização** clara por domínio
- ✅ **Manutenibilidade** alta

Este padrão garante que todas as entradas e saídas de funções tenham validação consistente e type-safe, melhorando significativamente a qualidade e confiabilidade da aplicação.

---

_Este guia deve ser seguido para todos os novos validators e atualizado conforme necessário._
