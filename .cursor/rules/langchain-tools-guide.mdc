---
alwaysApply: false
description: Guia Completo de Tools LangChain
---

# üõ†Ô∏è Guia Completo de Tools LangChain

## üìã Resumo Executivo

Este documento descreve o sistema completo de tools LangChain implementado no projeto Pare Azul API Intelligence. As tools s√£o ferramentas que permitem ao agente IA interagir com sistemas externos, executar opera√ß√µes espec√≠ficas e acessar dados em tempo real.

## üéØ Tipos de Tools LangChain

### **1. DynamicStructuredTool (Usado no projeto)**

```typescript
// src/tools/faq.tool.ts
export const faqSearchTool = new DynamicStructuredTool({
  name: 'faq_search',
  description: 'Search for frequently asked questions...',
  schema: FaqSearchSchema, // Schema Zod obrigat√≥rio
  func: async ({ query }) => {
    // L√≥gica da tool
    const results = await searchVectors(query);
    return results || 'No relevant FAQ entries found.';
  },
});
```

**Caracter√≠sticas:**

- **Valida√ß√£o autom√°tica** com schemas Zod
- **Type safety** completo
- **Entrada estruturada** (objeto tipado)
- **Ideal para** tools complexas com m√∫ltiplos par√¢metros

### **2. DynamicTool (Vers√£o mais simples)**

```typescript
// Exemplo de DynamicTool
const simpleTool = new DynamicTool({
  name: 'simple_calculator',
  description: 'Performs basic math operations',
  func: async (input: string) => {
    // Recebe string e precisa fazer parse manual
    const { operation, a, b } = JSON.parse(input);
    return performCalculation(operation, a, b);
  },
});
```

**Caracter√≠sticas:**

- **Entrada como string** (precisa fazer parse manual)
- **Menos valida√ß√£o** autom√°tica
- **Mais flex√≠vel** para casos simples
- **Ideal para** tools b√°sicas

### **3. Tool (Interface base)**

```typescript
// Interface base que todas as tools implementam
interface Tool {
  name: string;
  description: string;
  func: (input: any) => Promise<string>;
}
```

## üîß Composi√ß√£o e Depend√™ncias

### **1. Estrutura de uma Tool**

```typescript
// Componentes obrigat√≥rios
interface ToolStructure {
  name: string; // Nome √∫nico (usado pelo LLM)
  description: string; // Descri√ß√£o para o LLM entender quando usar
  schema?: ZodSchema; // Valida√ß√£o de entrada (apenas DynamicStructuredTool)
  func: Function; // L√≥gica de execu√ß√£o
}
```

### **2. Depend√™ncias no projeto**

```typescript
// src/tools/faq.tool.ts
import { DynamicStructuredTool } from '@langchain/core/tools';
import { z } from 'zod';
import { searchVectors } from '../utils/vector-search.util';
import { logger } from '../utils/logger.util';

// Depend√™ncias:
// - @langchain/core/tools (LangChain)
// - zod (valida√ß√£o)
// - Utils internos (l√≥gica de neg√≥cio)
```

### **3. Hierarquia de Depend√™ncias**

```
Tool
‚îú‚îÄ‚îÄ LangChain Core Tools
‚îú‚îÄ‚îÄ Zod (valida√ß√£o)
‚îú‚îÄ‚îÄ Utils (l√≥gica de neg√≥cio)
‚îú‚îÄ‚îÄ Services (camada de neg√≥cio)
‚îú‚îÄ‚îÄ APIs (integra√ß√µes externas)
‚îî‚îÄ‚îÄ Database (persist√™ncia)
```

## üéØ Como as Tools s√£o Usadas

### **1. Sele√ß√£o pelo LLM**

```typescript
// O LLM analisa o input e decide qual tool usar
const userInput = "Preciso de internet para usar o aplicativo?";

// LLM processa e decide:
{
    "tool": "faq_search",
    "toolInput": {
        "query": "internet para usar o aplicativo"
    }
}
```

### **2. Processo de Execu√ß√£o**

```typescript
// 1. LLM identifica necessidade de tool
// 2. Seleciona tool baseada na descri√ß√£o
// 3. Chama tool com par√¢metros validados
// 4. Tool executa l√≥gica de neg√≥cio
// 5. Retorna resultado para LLM
// 6. LLM incorpora resultado na resposta final
```

### **3. Valida√ß√£o Autom√°tica**

```typescript
// DynamicStructuredTool valida automaticamente
const FaqSearchSchema = z.object({
  query: z.string().describe('The question to search for'),
});

// Se input inv√°lido, tool retorna erro antes da execu√ß√£o
```

## üèóÔ∏è Onde est√° a L√≥gica das Tools

### **1. Estrutura no projeto**

```
src/tools/
‚îú‚îÄ‚îÄ index.ts              # Agrega√ß√£o de todas as tools
‚îú‚îÄ‚îÄ faq.tool.ts          # Tool de busca vetorial
‚îú‚îÄ‚îÄ database.tool.ts     # Tools de banco de dados
‚îî‚îÄ‚îÄ activation.tools.ts  # Tools de ativa√ß√£o
```

### **2. L√≥gica de Neg√≥cio**

```typescript
// src/tools/faq.tool.ts
export const faqSearchTool = new DynamicStructuredTool({
  name: 'faq_search',
  description: 'Search for frequently asked questions...',
  schema: FaqSearchSchema,
  func: async ({ query }) => {
    // L√ìGICA AQUI:
    // 1. Chama utility de busca vetorial
    // 2. Processa resultados
    // 3. Retorna resposta formatada
    const results = await searchVectors(query);
    return results || 'No relevant FAQ entries found.';
  },
});
```

### **3. Separa√ß√£o de Responsabilidades**

```typescript
// Tool = Interface + Valida√ß√£o
// Service = L√≥gica de neg√≥cio
// Util = Opera√ß√µes espec√≠ficas
// API = Integra√ß√µes externas

// Exemplo:
Tool (faq.tool.ts) ‚Üí Util (vector-search.util.ts) ‚Üí Service (memory.service.ts) ‚Üí API (Supabase)
```

## üîó Como Associar Tools ao Agente

### **1. Agrega√ß√£o de Tools**

```typescript
// src/tools/index.ts
export function createAllTools() {
  return [
    ...activationTools, // Tools de ativa√ß√£o
    ...databaseTools, // Tools de banco
    ...faqTools, // Tools de FAQ
  ];
}
```

### **2. Associa√ß√£o ao Agente**

```typescript
// src/agents/assistant/agent.ts
export const createAssistantAgent = async (payload: any) => {
  const tools = createAllTools(); // Pega todas as tools

  const agent = await createOpenAIToolsAgent({
    llm,
    tools, // Passa tools para o agente
    prompt: promptTemplate,
  });

  return new AgentExecutor({
    agent,
    tools, // Mesmas tools para o executor
    // ... outras configura√ß√µes
  });
};
```

### **3. Disponibilidade no Prompt**

```typescript
// src/agents/assistant/prompt.ts
// O prompt deve mencionar as tools dispon√≠veis
const systemPrompt = `
You have access to these tools:
- faq_search: Search the knowledge base
- get_user_info: Get user information
- checkVehicleCurrentActivations: Check vehicle activations
// ... outras tools
`;
```

## üìä Compara√ß√£o de Tipos de Tools

| Caracter√≠stica   | DynamicStructuredTool | DynamicTool | Tool Custom |
| ---------------- | --------------------- | ----------- | ----------- |
| **Valida√ß√£o**    | Autom√°tica (Zod)      | Manual      | Manual      |
| **Type Safety**  | Completo              | Parcial     | Nenhum      |
| **Entrada**      | Objeto tipado         | String      | Qualquer    |
| **Complexidade** | Alta                  | M√©dia       | Baixa       |
| **Manuten√ß√£o**   | F√°cil                 | M√©dia       | Dif√≠cil     |
| **Performance**  | Boa                   | Boa         | Vari√°vel    |

## üéØ Melhores Pr√°ticas para Tools

### **1. Design de Tools**

```typescript
// ‚úÖ BOM: Nome descritivo e √∫nico
name: 'faq_search';

// ‚ùå RUIM: Nome gen√©rico
name: 'search';

// ‚úÖ BOM: Descri√ß√£o clara para o LLM
description: 'Search for frequently asked questions and answers in the knowledge base using vector similarity';

// ‚ùå RUIM: Descri√ß√£o vaga
description: 'Search stuff';
```

### **2. Valida√ß√£o Robusta**

```typescript
// ‚úÖ BOM: Schema detalhado
const FaqSearchSchema = z.object({
  query: z
    .string()
    .min(1, 'Query cannot be empty')
    .max(500, 'Query too long')
    .describe('The question to search for'),
});

// ‚ùå RUIM: Schema b√°sico
const BasicSchema = z.object({
  query: z.string(),
});
```

### **3. Error Handling**

```typescript
// ‚úÖ BOM: Tratamento de erros robusto
func: async ({ query }) => {
  try {
    const results = await searchVectors(query);
    return results || 'No relevant FAQ entries found.';
  } catch (error) {
    logger.error('[FaqTool] Error:', error);
    return 'I encountered an error while searching. Please try again.';
  }
};

// ‚ùå RUIM: Sem tratamento de erros
func: async ({ query }) => {
  const results = await searchVectors(query);
  return results;
};
```

## üîÑ Fluxo de Execu√ß√£o das Tools

### **1. Ciclo de Vida**

```
1. LLM analisa input
2. Identifica necessidade de tool
3. Seleciona tool apropriada
4. Valida par√¢metros (se DynamicStructuredTool)
5. Executa fun√ß√£o da tool
6. Processa resultado
7. Incorpora na resposta final
```

### **2. Logs de Execu√ß√£o**

```json
{
  "action": {
    "tool": "faq_search",
    "toolInput": {
      "query": "internet para usar o aplicativo"
    },
    "toolCallId": "call_NL7c5eKTtq3Vx2AkwJPwnS2a"
  },
  "observation": "Here are some relevant FAQ entries that might help:\n\nSim, √© necess√°rio ter conex√£o..."
}
```

## üöÄ Vantagens da Arquitetura Atual

### **1. Modularidade**

- Tools independentes e reutiliz√°veis
- F√°cil adicionar novas capacidades
- Separa√ß√£o clara de responsabilidades

### **2. Type Safety**

- Valida√ß√£o autom√°tica com Zod
- IntelliSense completo
- Detec√ß√£o de erros em tempo de compila√ß√£o

### **3. Manutenibilidade**

- C√≥digo organizado e documentado
- F√°cil debugging e testing
- Evolu√ß√£o independente de cada tool

### **4. Performance**

- Valida√ß√£o eficiente
- Cache inteligente
- Execu√ß√£o otimizada

## üìà Recomenda√ß√µes de Melhoria

### **1. Tool Registry**

```typescript
// Criar um registry centralizado de tools
class ToolRegistry {
  private tools = new Map();

  register(tool: Tool) {
    this.tools.set(tool.name, tool);
  }

  get(name: string) {
    return this.tools.get(name);
  }
}
```

### **2. Tool Metrics**

```typescript
// Adicionar m√©tricas de uso das tools
interface ToolMetrics {
  name: string;
  callCount: number;
  averageExecutionTime: number;
  errorRate: number;
}
```

### **3. Tool Testing**

```typescript
// Testes unit√°rios para cada tool
describe('FaqSearchTool', () => {
  it('should search FAQ successfully', async () => {
    const result = await faqSearchTool.func({ query: 'test' });
    expect(result).toContain('relevant FAQ entries');
  });
});
```

## üéØ Conclus√£o

A arquitetura de tools no projeto est√° muito bem estruturada e segue as melhores pr√°ticas do LangChain. O uso de `DynamicStructuredTool` com valida√ß√£o Zod garante type safety e robustez, enquanto a separa√ß√£o clara de responsabilidades facilita manuten√ß√£o e evolu√ß√£o.

As principais melhorias seriam implementar um **Tool Registry** centralizado, adicionar **m√©tricas de uso** e criar **testes automatizados** para cada tool.

---

_Este guia deve ser atualizado conforme a evolu√ß√£o do projeto e descobertas de melhores pr√°ticas._
